include( ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME} )
if ( NOT DEFINED SOURCES )
  message ( FATAL_ERROR "List of source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PRIVATE )
  message ( FATAL_ERROR "List of private header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PUBLIC )
  message ( FATAL_ERROR "List of public header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED SOURCES_SGFC )
  message ( FATAL_ERROR "List of SGFC source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_SGFC )
  message ( FATAL_ERROR "List of SGFC header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()

# SGFC is written in C, but because libsgfc++ patches the SGFC source code the
# files listed here now contain C++ snippets and therefore must be built with
# the C++ compiler. Here we explicitly configure CMake to override the default
# compiler behaviour, which is to derive the language (C) from the file
# extension (.c).
set_source_files_properties (
  ../sgfc/save.c
  ../sgfc/util.c
  PROPERTIES LANGUAGE CXX
)

# When compiling with MSVC, disable the compiler warning C4996 for SGFC source
# files. The warning complains about sprintf, strcpy and other similar functions
# being unsafe. Although ignoring compiler warnings is not a good practice in
# general, in this case it's practical because replacing the sprintf et al.
# functions with what Microsoft is calling their "secure" counterparts (e.g.
# sprintf_s) is quite controversial.
if ( ${MSVC} )
  set_source_files_properties(
    ${SOURCES_SGFC}
    PROPERTIES
    COMPILE_DEFINITIONS _CRT_SECURE_NO_WARNINGS
  )
endif()

# An Xcode project that is generated by CMake doesn't build the shared or static
# library targets that we define further down, if the library targets only
# contains object files from the object library. Whether this is a deficiency in
# Xcode or in CMake's Xcode generator is unknown, but the problem seems to be
# well known, as it is even acknowledged in the CMake docs for object libraries
# [1].
#
#   Some native build systems (such as Xcode) may not like targets that have
#   only object files, so consider adding at least one real source file to
#   any target that references $<TARGET_OBJECTS:objlib>.
#
# Here we follow the suggested workaround and remove one source file from the
# list that will be compiled for the object library, for the only reason that
# we can add it to the shared and static library targets further down. Any
# fill will do, the one we pick here has no special significance.
#
# [1] https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries
set ( SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY SgfcUtility.cpp )
list (
  REMOVE_ITEM
  SOURCES
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# This is an "object library" target: It compiles the sources but doesn't
# aggregate them into an actual shared or static library yet. The purpose of
# this is to avoid compiling the sources twice, once for the shared library and
# once for the static library.
add_library (
  ${OBJECT_LIBRARY_TARGET_NAME}
  OBJECT
  ${SOURCES_SGFC}
  ${SOURCES}
  # We list header files here only because we want CMake to add them to an
  # Xcode or Visual Studio project that it generates.
  ${HEADERS_SGFC}
  ${HEADERS_PUBLIC}
  ${HEADERS_PRIVATE}
)

# Shared libraries need PIC. Static libraries don't need PIC, so the static
# library built from the object library will be a bit less performant than it
# could be. That's the price we pay for compiling only once. If we wanted an
# ultra-fast static library we would have to compile twice.
set_property (
  TARGET ${OBJECT_LIBRARY_TARGET_NAME}
  PROPERTY POSITION_INDEPENDENT_CODE 1
)

# Here we finally build the shared and static libraries. We build them
# from the same set of object files.
if ( ${ENABLE_SHARED_LIBRARY} )
  add_library (
    ${SHARED_LIBRARY_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  add_library (
    ${STATIC_LIBRARY_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()

# For macOS and iOS we also provide a shared library framework and a static
# library framework. They are composed of the exact same stuff as the regular
# libraries.
if ( ${ENABLE_SHARED_FRAMEWORK} )
  add_library (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # Furtherdown we invoke set_property() to set the targets' PUBLIC_HEADER
    # property. For the shared and static library targets this works fine and
    # causes CMake to copy the header files to their proper destination at
    # installation time. For the framework targets, just setting the PUBLIC_HEADER
    # property alone is not sufficient: We also have to list the public headers
    # here in this add_library() invocation, otherwise CMake does not copy them
    # into the framework bundle at build time. This workaround can be found on
    # the CMake mailing list [1] in a thread dating from 2015.
    # [1] http://cmake.3232098.n2.nabble.com/OS-X-framework-headers-with-capital-letters-td7591087.html
    ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  add_library (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # For an explanation of this line, see the comment above in the add_library()
    # command for SHARED_FRAMEWORK_TARGET_NAME.
    ${HEADERS_PUBLIC}
  )
endif()

# Here we associate the public header files with the library and framework
# targets. This causes CMake to install them automatically, without us having
# to define a special install rule.
# - For frameworks this is necessary because each framework gets its own copy
#   of the header files.
# - For the libraries we would need only one association because when installed
#   both libraries share the same set of header files. We still associate the
#   files with both library targets, to make sure that the header files will be
#   installed even if the user chooses to build and install only one of the
#   libraries. If the user builds and installs both libraries, then the header
#   files will get installed twice.
#
# Note: It's not possible to make the association with all targets at the same
# time with only one single invocation of set_target_properties(). For unknown
# reasons this does not work, it only copies one single header file to be copied
# instead of the the entire set.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_property (
    TARGET ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()

# Set the targets' output names, which in some cases deviate from the target
# name.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_target_properties (
    ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_target_properties (
    ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_FRAMEWORK_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_FRAMEWORK_OUTPUT_NAME}"
  )
endif()

# Mark the framework targets as frameworks. Because of this CMake generates
# the framework bundle folder structure on macOS/iOS.
# TODO: Set more properties. Check out this example:
# https://cmake.org/cmake/help/latest/prop_tgt/FRAMEWORK.html
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()

# Install all artifcats.
#install (
#  TARGETS
#  ${SHARED_LIBRARY_TARGET_NAME}
#  ${STATIC_LIBRARY_TARGET_NAME}
#  ${SHARED_FRAMEWORK_TARGET_NAME}
#  ${STATIC_FRAMEWORK_TARGET_NAME}

  # This lets the user build and install only one of the targets, e.g.
  #   cmake --build . --target libsgfc++_static
  #   cmake --install . --prefix /path/to/destfolder
  # Note that this setting applies to all artifact types because there isn't
  # an artifact type selector in front of it.
#  OPTIONAL

  # Here we start setting properties for the "Framework" artifact type.
#  FRAMEWORK
  # Libraries and header files have default destinations ("lib", "include") but
  # frameworks don't.
#  DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
#)

if ( ${ENABLE_SHARED_LIBRARY} )
  install (
    TARGETS
    ${SHARED_LIBRARY_TARGET_NAME}
  )
endif()
if ( ENABLE_STATIC_LIBRARY )
  install (
    TARGETS
    ${STATIC_LIBRARY_TARGET_NAME}
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  install (
    TARGETS
    ${SHARED_FRAMEWORK_TARGET_NAME}
    FRAMEWORK
    DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
  )
endif()
if ( ENABLE_STATIC_FRAMEWORK )
  install (
    TARGETS
    ${STATIC_FRAMEWORK_TARGET_NAME}
    FRAMEWORK
    DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
  )
endif()
