include( ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME} )
if ( NOT DEFINED SOURCES )
  message ( FATAL_ERROR "List of source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PRIVATE )
  message ( FATAL_ERROR "List of private header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PUBLIC )
  message ( FATAL_ERROR "List of public header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED SOURCES_SGFC )
  message ( FATAL_ERROR "List of SGFC source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_SGFC )
  message ( FATAL_ERROR "List of SGFC header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()

# Setting VERSION_NO_MAIN "defines away" the SGFC main() function. An
# alternative would be to exclude main.c from the build, but this would make
# the file unavailable in IDEs.
set_source_files_properties (
  ../sgfc/src/main.c
  PROPERTIES
  COMPILE_DEFINITIONS VERSION_NO_MAIN
)

# When compiling with MSVC, disable the compiler warning C4996 for SGFC source
# files. The warning complains about sprintf, strcpy and other similar functions
# being unsafe. Although ignoring compiler warnings is not a good practice in
# general, in this case it's practical because replacing the sprintf et al.
# functions with what Microsoft is calling their "secure" counterparts (e.g.
# sprintf_s) is quite controversial.
if ( ${MSVC} )
  set_source_files_properties(
    ${SOURCES_SGFC}
    PROPERTIES
    COMPILE_DEFINITIONS _CRT_SECURE_NO_WARNINGS
  )
endif()

# When compiling with MSVC, disable the compiler warning C4250 for libsgfc++
# source files. The warning complains when a subclass in a multiple-inheritance
# diamond pattern inherits a member from one of its base classes. The compiler
# generates this warning even for completely legal code. Example:
# SgfcBoardSizeProperty inherits the root interface ISgfcProperty twice, once
# via subclassing SgfcProperty and once via subclassing ISgfcBoardSizeProperty.
# In this inheritance diamond the GetPropertyType() method is declared once as
# "pure virtual" in the root interface, and is implemented exactly once in
# SgfcProperty. Despite this perfectly legal and unambiguos class structure the
# compiler generates C4250. There is no other choice but to suppress the warning
# to prevent the build log from being flooded with useless warnings.
if ( ${MSVC} )
  set_source_files_properties(
    ${SOURCES}
    PROPERTIES
    COMPILE_OPTIONS /wd4250
  )
endif()

# An Xcode project that is generated by CMake doesn't build the shared or static
# library targets that we define further down, if the library targets only
# contains object files from the object library. Whether this is a deficiency in
# Xcode or in CMake's Xcode generator is unknown, but the problem seems to be
# well known, as it is even acknowledged in the CMake docs for object libraries
# [1].
#
#   Some native build systems (such as Xcode) may not like targets that have
#   only object files, so consider adding at least one real source file to
#   any target that references $<TARGET_OBJECTS:objlib>.
#
# Here we follow the suggested workaround and remove one source file from the
# list that will be compiled for the object library, for the only reason that
# we can add it to the shared and static library targets further down. Any
# fill will do, the one we pick here has no special significance.
#
# [1] https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries
set ( SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY SgfcUtility.cpp )
list (
  REMOVE_ITEM
  SOURCES
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# The following two targets are "object library" targets: They compile the
# sources but don't aggregate them into an actual shared or static library yet.
# The purpose of this is to avoid compiling the sources twice, once for the
# shared/static library and once for the shared/static library framework.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  add_library (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES_SGFC}
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_SGFC}
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  add_library (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES_SGFC}
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_SGFC}
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()

# Here we finally build the shared and static libraries. We build them
# from the same set of object files.
if ( ${ENABLE_SHARED_LIBRARY} )
  add_library (
    ${SHARED_LIBRARY_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  add_library (
    ${STATIC_LIBRARY_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()

# For macOS and iOS we also provide a shared library framework and a static
# library framework. They are composed of the exact same stuff as the regular
# libraries.
if ( ${ENABLE_SHARED_FRAMEWORK} )
  add_library (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # Furtherdown we invoke set_property() to set the targets' PUBLIC_HEADER
    # property. For the shared and static library targets this works fine and
    # causes CMake to copy the header files to their proper destination at
    # installation time. For the framework targets, just setting the PUBLIC_HEADER
    # property alone is not sufficient: We also have to list the public headers
    # here in this add_library() invocation, otherwise CMake does not copy them
    # into the framework bundle at build time. This workaround can be found on
    # the CMake mailing list [1] in a thread dating from 2015.
    # [1] http://cmake.3232098.n2.nabble.com/OS-X-framework-headers-with-capital-letters-td7591087.html
    ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  add_library (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # For an explanation of this line, see the comment above in the add_library()
    # command for SHARED_FRAMEWORK_TARGET_NAME.
    ${HEADERS_PUBLIC}
  )
endif()

# Generate the export header file.
include ( GenerateExportHeader )
generate_export_header (
  ${EXPORT_HEADER_TARGET_NAME}

  # EXPORT_HEADER_TARGET_NAME is variable, but we need to have a static base
  # name that does not change, so that the source code can use preprocessor
  # macros with stable names.
  BASE_NAME ${EXPORT_HEADER_BASE_NAME}

  # The default header file name looks ugly: sgfcplusplus_export.h
  # Let's define a file name that looks more in line with the rest of the
  # project.
  EXPORT_FILE_NAME ${EXPORT_HEADER_FILE_NAME}
)

# Here we associate the public header files with the library and framework
# targets. This causes CMake to install them automatically, without us having
# to define a special install rule.
# - For frameworks this is necessary because each framework gets its own copy
#   of the header files.
# - For the libraries we would need only one association because when installed
#   both libraries share the same set of header files. We still associate the
#   files with both library targets, to make sure that the header files will be
#   installed even if the user chooses to build and install only one of the
#   libraries. If the user builds and installs both libraries, then the header
#   files will get installed twice.
#
# Note: It's not possible to make the association with all targets at the same
# time with only one single invocation of set_target_properties(). For unknown
# reasons this does not work, it only copies one single header file to be copied
# instead of the the entire set.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_property (
    TARGET ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()

# Set the targets' output names, which in some cases deviate from the target
# name.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_target_properties (
    ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_target_properties (
    ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_FRAMEWORK_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_FRAMEWORK_OUTPUT_NAME}"
  )
endif()

# Mark the framework targets as frameworks. Because of this CMake generates
# the framework bundle folder structure on macOS/iOS.
# TODO: Set more properties. Check out this example:
# https://cmake.org/cmake/help/latest/prop_tgt/FRAMEWORK.html
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()

# Define additional folders where to look for include files.
# - The first folder is where the export header file is located. See further up
#   where we generate that file with generate_export_header(). This folder is
#   used during the build of the project only. Later the export header file will
#   be installed alongside the public headers, so it will be found without an
#   include directory by the #include statements because they use the quotes
#   syntax.
# - The second folder is where our own public headers are located in the
#   install tree. This folder is not used during our own build, but during the
#   build of downstream projects that make use of our exported targets.
#   Important: For this we use ${CMAKE_INSTALL_INCLUDEDIR}, not
#   ${PUBLIC_HEADER_DESTINATION_FOLDER_NAME}, because we want downstream
#   projects to use the subfolder in their #include statements. Example:
#   #include <libsgfcplusplus/Foo.h>.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_include_directories (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_include_directories (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_include_directories (
    ${SHARED_LIBRARY_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  target_include_directories (
    ${STATIC_LIBRARY_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  target_include_directories (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  target_include_directories (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PUBLIC
    "$<BUILD_INTERFACE:${EXPORT_HEADER_FILE_FOLDER}>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
  )
endif()

# Define additional compile options.
# - EXPORT_HEADER_EXPORTS_MACRO_NAME macro: Must be defined for the shared
#   library/framework builds to turn on symbol visibility.
# - EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME macro: Must be defined for the static
#   library/framework builds to turn off symbol visibility.
# - COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS: Tell the compiler that
#   C functions may throw exceptions. See main CMake config file for details.
# - VERSION, INTERFACE_<target>_MAJOR_VERSION, COMPATIBLE_INTERFACE_STRING,
#   SOVERSION: Configure targets with version information properties. This is
#   important when downstream projects import the exported targets of this
#   project. The SOVERSION property causes additional output files to be
#   generated. The INTERFACE_<target>_MAJOR_VERSION and
#   COMPATIBLE_INTERFACE_STRING properties combine to ensure that downstream
#   targets cannot link the same target using two different versions.
#   See "Compatible Interface Properties" in the cmake-buildsystem(7) docs.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_compile_options (
    ${SHARED_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
  set_target_properties (
    ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTIES
    VERSION ${PROJECT_VERSION}
    INTERFACE_${SHARED_LIBRARY_TARGET_NAME}_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
    SOVERSION ${PROJECT_VERSION_MAJOR}
  )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    APPEND PROPERTY COMPATIBLE_INTERFACE_STRING ${SHARED_LIBRARY_TARGET_NAME}_MAJOR_VERSION
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  target_compile_options (
    ${STATIC_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
  set_target_properties (
    ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTIES
    VERSION ${PROJECT_VERSION}
    INTERFACE_${STATIC_LIBRARY_TARGET_NAME}_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
    SOVERSION ${PROJECT_VERSION_MAJOR}
  )
  set_property (
    TARGET ${STATIC_LIBRARY_TARGET_NAME}
    APPEND PROPERTY COMPATIBLE_INTERFACE_STRING ${STATIC_LIBRARY_TARGET_NAME}_MAJOR_VERSION
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  target_compile_options (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    VERSION ${PROJECT_VERSION}
    INTERFACE_${SHARED_FRAMEWORK_TARGET_NAME}_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
    SOVERSION ${PROJECT_VERSION_MAJOR}
  )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    APPEND PROPERTY COMPATIBLE_INTERFACE_STRING ${SHARED_FRAMEWORK_TARGET_NAME}_MAJOR_VERSION
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  target_compile_options (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    VERSION ${PROJECT_VERSION}
    INTERFACE_${STATIC_FRAMEWORK_TARGET_NAME}_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
    SOVERSION ${PROJECT_VERSION_MAJOR}
  )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    APPEND PROPERTY COMPATIBLE_INTERFACE_STRING ${STATIC_FRAMEWORK_TARGET_NAME}_MAJOR_VERSION
  )
endif()

# More compile options: Shared libraries need PIC.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  set_property (
    TARGET ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()

# Install options
# - On some systems CMake automatically populates the LIBRARY and PUBLIC_HEADER
#   destinations with values defined by the GNUInstallDirs module (e.g. macOS
#   with CMake 3.11 and Xcode, Windows with CMake 3.16 and VisualStudio). On
#   other systems CMake does not do it automatically (e.g. Ubuntu 18.04 with
#   CMake 3.12 and GCC, which corresponds to the Travis build system "bionic").
#   To satisfy all systems we have to populate the destinations manually.
# - Even if PUBLIC_HEADER is populated automatically, the default value (which
#   is CMAKE_INSTALL_INCLUDEDIR) is not OK for the static and shared libraries
#   because we want to install into a subfolder so as not to pollute the main
#   include folder. For frameworks on the other hand the PUBLIC_HEADER and
#   LIBRARY destinations must be populated with ${CMAKE_INSTALL_INCLUDEDIR} and
#   ${CMAKE_INSTALL_LIBDIR} because those folders are relative to the framework
#   folder - here we don't want another subfolder, the framework folder itself
#   provides that additional level.
# - EXPORT associates the files installed by the target with a named "export".
#   See the install(EXPORT) command below for more information.
if ( ${ENABLE_SHARED_LIBRARY} )
  install (
    TARGETS ${SHARED_LIBRARY_TARGET_NAME}
    EXPORT ${EXPORT_NAME}
    LIBRARY DESTINATION ${LIBRARY_DESTINATION_FOLDER_NAME}
    PUBLIC_HEADER DESTINATION ${PUBLIC_HEADER_DESTINATION_FOLDER_NAME}
  )
endif()
if ( ENABLE_STATIC_LIBRARY )
  install (
    TARGETS ${STATIC_LIBRARY_TARGET_NAME}
    EXPORT ${EXPORT_NAME}
    ARCHIVE DESTINATION ${LIBRARY_DESTINATION_FOLDER_NAME}
    PUBLIC_HEADER DESTINATION ${PUBLIC_HEADER_DESTINATION_FOLDER_NAME}
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  install (
    TARGETS ${SHARED_FRAMEWORK_TARGET_NAME}
    EXPORT ${EXPORT_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
if ( ENABLE_STATIC_FRAMEWORK )
  install (
    TARGETS ${STATIC_FRAMEWORK_TARGET_NAME}
    EXPORT ${EXPORT_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()

# Export targets and define the CMake package
if ( ${AT_LEAST_ONE_LIBRARY_IS_ENABLED} )
  # This generates and installs a CMake file containing CMake magic to import
  # the targets exported by this project into another project, to be used in the
  # other project just as if the targets were defined in the other project. The
  # important point here is that when the other project uses one of the exported
  # targets, the files from the **installation** tree will be used! Targets need
  # to be associated with an export first - see above where various install()
  # commands use the EXPORT option.
  #
  # Additional notes:
  # - Because we export only library targets we can place the install(EXPORT)
  #   command in this CMakeLists.txt file. If we wanted to export other targets
  #   defined in other CMakeLists.txt files we would have to place the
  #   install(EXPORT) command in the top-level CMakeLists.txt file.
  install (
    EXPORT ${EXPORT_NAME}
    NAMESPACE ${EXPORT_NAMESPACE}
    DESTINATION ${EXPORT_DESTINATION_FOLDER_NAME}
  )

  # Needed for the helper commands needed to set up the package
  include( CMakePackageConfigHelpers )

  # Generate the package configuration file based on a template
  configure_package_config_file (
    ${CMAKE_CURRENT_SOURCE_DIR}/${PACKAGE_CONFIGURATION_TEMPLATE_FILE_NAME}
    ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGURATION_FILE_NAME}
    INSTALL_DESTINATION ${EXPORT_DESTINATION_FOLDER_NAME}
  )

  # Generate the package version file.
  write_basic_package_version_file (
    ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_VERSION_FILE_NAME}
    VERSION "${PROJECT_VERSION}"
    COMPATIBILITY AnyNewerVersion
  )

  # Install the package configuration and version files
  install (
    FILES
    ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGURATION_FILE_NAME}
    ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_VERSION_FILE_NAME}
    DESTINATION ${EXPORT_DESTINATION_FOLDER_NAME}
  )

  # Export targets from the build tree
  # TODO: This likely needs another package configuration file to be used
  # conveniently.
  # See https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html
  export (
    EXPORT ${EXPORT_NAME}
    FILE "${CMAKE_CURRENT_BINARY_DIR}/cmake/${EXPORT_NAME}.cmake"
    NAMESPACE ${EXPORT_NAMESPACE}
  )
endif()
