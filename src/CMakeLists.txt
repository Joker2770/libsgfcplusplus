# Because we don't list files explicitly, if a file is added or removed we need
# to run
#  touch CMakeLists.txt
# in the project root folder to trigger re-generation of the build system.
# TODO Don't do globbing. The argument that convinces me is that someone
# downstream might get into trouble if for some reason they don't have a clean
# source tree.
# TODO Maybe we should also add header files and other stuff? Test what happens
# if we generate an Xcode or VisualStudio project. At least the header files
# should be part of the projects.
file ( GLOB_RECURSE SOURCES *.cpp )
file ( GLOB_RECURSE HEADERS_PRIVATE *.h )
file ( GLOB_RECURSE HEADERS_PUBLIC ../include/*.h )
file ( GLOB_RECURSE SOURCES_SGFC ../sgfc/*.c )
file ( GLOB_RECURSE HEADERS_SGFC ../sgfc/*.h )

# SGFC is written in C, but because libsgfc++ patches the SGFC source code the
# files listed here now contain C++ snippets and therefore must be built with
# the C++ compiler. Here we explicitly configure CMake to override the default
# compiler behaviour, which is to derive the language (C) from the file
# extension (.c).
set_source_files_properties (
  ../sgfc/save.c
  ../sgfc/util.c
  PROPERTIES LANGUAGE CXX
)

# An Xcode project that is generated by CMake doesn't build the shared or static
# library targets that we define further down, if the library targets only
# contains object files from the object library. Whether this is a deficiency in
# Xcode or in CMake's Xcode generator is unknown, but the problem seems to be
# well known, as it is even acknowledged in the CMake docs for object libraries
# [1].
#
#   Some native build systems (such as Xcode) may not like targets that have
#   only object files, so consider adding at least one real source file to
#   any target that references $<TARGET_OBJECTS:objlib>.
#
# Here we follow the suggested workaround and remove one source file from the
# list that will be compiled for the object library, for the only reason that
# we can add it to the shared and static library targets further down. Any
# fill will do, the one we pick here has no special significance.
#
# [1] https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries
set ( SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY SgfcUtility.cpp )
list (
  REMOVE_ITEM
  SOURCES
  ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# This is an "object library" target: It compiles the sources but doesn't
# aggregate them into an actual shared or static library yet. The purpose of
# this is to avoid compiling the sources twice, once for the shared library and
# once for the static library.
add_library (
  ${OBJECT_LIBRARY_TARGET_NAME}
  OBJECT
  ${SOURCES_SGFC}
  ${SOURCES}
  # We list header files here only because we want CMake to add them to an
  # Xcode or Visual Studio project that it generates.
  ${HEADERS_SGFC}
  ${HEADERS_PUBLIC}
  ${HEADERS_PRIVATE}
)

# Shared libraries need PIC. Static libraries don't need PIC, so the static
# library built from the object library will be a bit less performant than it
# could be. That's the price we pay for compiling only once. If we wanted an
# ultra-fast static library we would have to compile twice.
set_property (
  TARGET ${OBJECT_LIBRARY_TARGET_NAME}
  PROPERTY POSITION_INDEPENDENT_CODE 1
)

# Here we finally build the shared and static libraries. We build them
# from the same set of object files.
add_library (
  ${SHARED_LIBRARY_TARGET_NAME}
  SHARED
  $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)
add_library (
  ${STATIC_LIBRARY_TARGET_NAME}
  STATIC
  $<TARGET_OBJECTS:${OBJECT_LIBRARY_TARGET_NAME}>
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# Here we associate the public header files with the library targets. This
# causes CMake to install them automatically, without us having to define a
# special install rule. By associating the same set of header files with both
# libraries we make sure that the header files will be installed even if the
# user chooses to build and install only one of the libraries. If the user
# builds and installs both libraries, then the header files will get installed
# twice.
set_property (
  TARGET ${SHARED_LIBRARY_TARGET_NAME}
  PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
)
set_property (
  TARGET ${STATIC_LIBRARY_TARGET_NAME}
  PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
)

# Install the shared and static library artifacts. If we wanted to we could
# specify special rules for different file types (e.g. for the library files,
# or for the include files), but we don't. If we wanted we could also specify
# a special DESTINATION subfolder, but we don't - by omitting the DESTINATION
# option we allow CMake to set sensible defaults (e.g. "lib" subfolder for
# library files, "include" subfolder for the public header files).
install (
  TARGETS
  ${SHARED_LIBRARY_TARGET_NAME}
  ${STATIC_LIBRARY_TARGET_NAME}

  # This lets the user build and install only one of the two libraries, e.g.
  #   cmake --build . --target libsgfc++_static
  #   cmake --install . --prefix /path/to/destfolder
  OPTIONAL
)
