// Project includes
#include "../../SgfcPrivateConstants.h"
#include "SgfcMessageStream.h"

// C++ Standardd Library includes
#include <sstream>

namespace LibSgfcPlusPlus
{
  // ----------------------------------------------------------------------
  // Function prototypes used to interact with SGFC.
  // ----------------------------------------------------------------------

  /// @brief Acquires the message stream that was generated by SGFC during its
  /// most recent parsing of SGF content.
  ///
  /// This is a function prototype. The function is defined in SGFC, in the
  /// modified util.c.
  std::string AcquireSgfcMessageStream();

  /// @brief Resets the message stream stored in SGFC so that SGFC starts with
  /// a clean slate when it parses SGF content the next time.
  ///
  /// This is a function prototype. The function is defined in SGFC, in the
  /// modified util.c.
  void ResetSgfcMessageStream();

  // ----------------------------------------------------------------------
  // The SgfcMessageStream class.
  // ----------------------------------------------------------------------

  SgfcMessageStream::SgfcMessageStream()
    : rawMessageStreamContent(SgfcPrivateConstants::EmptyString)
    , messageStreamLines()
  {
    // TODO: Add multi-threading protection.
    // TODO: Ensure that nobody is stealing the stream content from an SGFC controller.

    this->rawMessageStreamContent = AcquireSgfcMessageStream();
    SplitRawMessageStreamContentIntoLines();

    ResetSgfcMessageStream();
  }

  SgfcMessageStream::~SgfcMessageStream()
  {
  }

  void SgfcMessageStream::SplitRawMessageStreamContentIntoLines()
  {
    std::stringstream messageStream(this->rawMessageStreamContent);
    std::string line;

    // The SGFC function PrintError() exclusively uses newline characters to
    // delimit lines. This is a bit surprising, since SGFC has support for
    // flexible line endings when it writes SGF content to a file. If this
    // changes in a future SGFC implementation and and PrintError() starts to
    // use flexible line endings, too, then we will no longer be able to use
    // std::getline(), as that supports only a single character as the line
    // ending, but on Windows we can have two characters (CRLF). Note that in
    // that case we can use SgfcPrivateConstants::EndOfLineStringUsedBySgfc to
    // find out what line ending SGFC uses.
    while (std::getline(messageStream, line, SgfcPrivateConstants::NewlineCharacter))
    {
      this->messageStreamLines.push_back(line);
    }
  }

  std::vector<std::string> SgfcMessageStream::GetMessageStreamLines() const
  {
    return this->messageStreamLines;
  }

  std::string SgfcMessageStream::GetRawMessageStreamContent() const
  {
    return this->rawMessageStreamContent;
  }
}
