<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsgfc++: LibSgfcPlusPlus::SgfcUtility Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libsgfc++<span id="projectnumber">&#160;2.0.1</span>
   </div>
   <div id="projectbrief">A C++ library that uses SGFC to read and write SGF (Smart Game Format) data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lib_sgfc_plus_plus.html">LibSgfcPlusPlus</a></li><li class="navelem"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_utility.html">SgfcUtility</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_lib_sgfc_plus_plus_1_1_sgfc_utility-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LibSgfcPlusPlus::SgfcUtility Class Reference<div class="ingroups"><a class="el" href="group__internals.html">Internals</a> &#124; <a class="el" href="group__library-support.html">Library Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_utility.html" title="The SgfcUtility class is a container for static helper functions.">SgfcUtility</a> class is a container for static helper functions.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sgfc_utility_8h_source.html">SgfcUtility.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0021b00bd031fd37f9a44c5f28157cf2" id="r_a0021b00bd031fd37f9a44c5f28157cf2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0021b00bd031fd37f9a44c5f28157cf2">MapPropertyTypeToPropertyName</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType)</td></tr>
<tr class="memdesc:a0021b00bd031fd37f9a44c5f28157cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property name, as defined by the SGF standard, that corresponds to <em>propertyType</em>. <em>propertyType</em> must not be <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a>.  <br /></td></tr>
<tr class="separator:a0021b00bd031fd37f9a44c5f28157cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70c763ef71cd1ceb6f7b2a3a0b89cd7" id="r_ac70c763ef71cd1ceb6f7b2a3a0b89cd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac70c763ef71cd1ceb6f7b2a3a0b89cd7">MapPropertyNameToPropertyType</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:ac70c763ef71cd1ceb6f7b2a3a0b89cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SgfcPropertyType value that corresponds to <em>propertyName</em>. Returns <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> if <em>propertyName</em> cannot be mapped, which is the case if <em>propertyName</em> is not the name of a property as defined by the SGF standard.  <br /></td></tr>
<tr class="separator:ac70c763ef71cd1ceb6f7b2a3a0b89cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51722243fc5204219b615bde26ca0a61" id="r_a51722243fc5204219b615bde26ca0a61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51722243fc5204219b615bde26ca0a61">MapPropertyTypeToPropertyCategory</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType)</td></tr>
<tr class="memdesc:a51722243fc5204219b615bde26ca0a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property category, as defined by the SGF standard, that corresponds to <em>propertyType</em>.  <br /></td></tr>
<tr class="separator:a51722243fc5204219b615bde26ca0a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897286a22c488de7de680406804eb40" id="r_a4897286a22c488de7de680406804eb40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#ga42be009625cd53c61f0cec57792548f9">SgfcPropertyTraits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4897286a22c488de7de680406804eb40">MapPropertyTypeToPropertyTraits</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType)</td></tr>
<tr class="memdesc:a4897286a22c488de7de680406804eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property traits, as defined by the SGF standard, that the property with property type <em>propertyType</em> has.  <br /></td></tr>
<tr class="separator:a4897286a22c488de7de680406804eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8b22baa01c347f2c62edebd92339b" id="r_a66c8b22baa01c347f2c62edebd92339b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#ga3c2910dbdcf98ec5e930fe5b518829d7">SgfcNodeTraits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66c8b22baa01c347f2c62edebd92339b">MapPropertyCategoryToNodeTraits</a> (<a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a> propertyCategory)</td></tr>
<tr class="memdesc:a66c8b22baa01c347f2c62edebd92339b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node trait, as defined by the SGF standard, that corresponds to <em>propertyCategory</em>. Returns <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#afdec80eabad744d960012570dd3d2b91" title="An SgfcNodeTraits value that denotes a node that has no traits.">SgfcConstants::NodeTraitsNone</a> if <em>propertyCategory</em> cannot be mapped.  <br /></td></tr>
<tr class="separator:a66c8b22baa01c347f2c62edebd92339b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885906b3fcc411a3788821380911c86" id="r_ac885906b3fcc411a3788821380911c86"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#ga2c188a9d33131c58c39162299c847460">SgfcNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac885906b3fcc411a3788821380911c86">MapGameTypeToNumberValue</a> (<a class="el" href="group__public-api.html#ga628677a0792100aa0f813793d9df7750">SgfcGameType</a> gameType)</td></tr>
<tr class="memdesc:ac885906b3fcc411a3788821380911c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SgfcNumber value that corresponds to the SgfcGameType value <em>gameType</em>. <em>gameType</em> must not be SgfcGameType::Unknown.  <br /></td></tr>
<tr class="separator:ac885906b3fcc411a3788821380911c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb430d7674c2899e15f1147bf42e001a" id="r_aeb430d7674c2899e15f1147bf42e001a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__public-api.html#ga628677a0792100aa0f813793d9df7750">SgfcGameType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb430d7674c2899e15f1147bf42e001a">MapNumberValueToGameType</a> (<a class="el" href="group__public-api.html#ga2c188a9d33131c58c39162299c847460">SgfcNumber</a> gameTypeAsNumber)</td></tr>
<tr class="memdesc:aeb430d7674c2899e15f1147bf42e001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SgfcGameType value that corresponds to the Number value <em>gameTypeAsNumber</em>. Returns SgfcGameType::Unknown if the Number value cannot be mapped, which is the case if the Number value does not correspond to one of the known values defined by the SGF standard.  <br /></td></tr>
<tr class="separator:aeb430d7674c2899e15f1147bf42e001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d04413a0065d379b3ca26b88228a32" id="r_a07d04413a0065d379b3ca26b88228a32"><td class="memItemLeft" align="right" valign="top"><a id="a07d04413a0065d379b3ca26b88228a32" name="a07d04413a0065d379b3ca26b88228a32"></a>
static <a class="el" href="group__public-api.html#ga9c6f34d212170150f430da96e13bf5c7">SgfcExitCode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetSgfcExitCodeFromMessageCollection</b> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_message.html">ISgfcMessage</a> &gt; &gt; &amp;messageCollection)</td></tr>
<tr class="memdesc:a07d04413a0065d379b3ca26b88228a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an SgfcExitCode value that represents the messages in <em>messageCollection</em>. See the documentation of the individual enumeration values for details. <br /></td></tr>
<tr class="separator:a07d04413a0065d379b3ca26b88228a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd4cf366fcc948974d7a5df70012284" id="r_a6dd4cf366fcc948974d7a5df70012284"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd4cf366fcc948974d7a5df70012284">GetIsSgfDataValidFromMessageCollection</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_message.html">ISgfcMessage</a> &gt; &gt; &amp;messageCollection)</td></tr>
<tr class="memdesc:a6dd4cf366fcc948974d7a5df70012284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <em>messageCollection</em>, which is the result of an SGFC read or write operation, indicate that the piece of SGF data that was read or written is valid.  <br /></td></tr>
<tr class="separator:a6dd4cf366fcc948974d7a5df70012284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af82426fb2a58b7832538433c6e47f8" id="r_a1af82426fb2a58b7832538433c6e47f8"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af82426fb2a58b7832538433c6e47f8">MapArgumentTypeToCmdlineOption</a> (<a class="el" href="group__public-api.html#gafdc227d85ad60d7780ac2eadbd716800">SgfcArgumentType</a> argumentType)</td></tr>
<tr class="memdesc:a1af82426fb2a58b7832538433c6e47f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the command line option, as defined by the SGFC documentation, that corresponds to <em>argumentType</em>.  <br /></td></tr>
<tr class="separator:a1af82426fb2a58b7832538433c6e47f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38484a1ab36f428d57f569cfd2ea84c1" id="r_a38484a1ab36f428d57f569cfd2ea84c1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38484a1ab36f428d57f569cfd2ea84c1">GetTempFolderPath</a> ()</td></tr>
<tr class="memdesc:a38484a1ab36f428d57f569cfd2ea84c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full path of a folder that is suitable for temporary files. The path is guaranteed to exist and to be a directory. The returned path string is UTF-8 encoded.  <br /></td></tr>
<tr class="separator:a38484a1ab36f428d57f569cfd2ea84c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15b99a0451db7d677ec999d8ccaf0d6" id="r_ad15b99a0451db7d677ec999d8ccaf0d6"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad15b99a0451db7d677ec999d8ccaf0d6">GetUniqueTempFileName</a> ()</td></tr>
<tr class="memdesc:ad15b99a0451db7d677ec999d8ccaf0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique base name of a file that is extremely unlikely to already exist in the temporary folder returned by GetTempPath(). This method never returns the same value twice.  <br /></td></tr>
<tr class="separator:ad15b99a0451db7d677ec999d8ccaf0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacf83cf0a47f01aca53a5716e755ed1" id="r_aeacf83cf0a47f01aca53a5716e755ed1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeacf83cf0a47f01aca53a5716e755ed1">GetUniqueTempFilePath</a> ()</td></tr>
<tr class="memdesc:aeacf83cf0a47f01aca53a5716e755ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique absolute path of a file that is extremely unlikely to already exist in the temporary folder returned by GetTempPath(). The returned path string is UTF-8 encoded. This method never returns the same value twice.  <br /></td></tr>
<tr class="separator:aeacf83cf0a47f01aca53a5716e755ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbe812b6103a4929e749685134d2e1e" id="r_afcbe812b6103a4929e749685134d2e1e"><td class="memItemLeft" align="right" valign="top"><a id="afcbe812b6103a4929e749685134d2e1e" name="afcbe812b6103a4929e749685134d2e1e"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>JoinPathComponents</b> (const std::string &amp;component1, const std::string &amp;component2)</td></tr>
<tr class="memdesc:afcbe812b6103a4929e749685134d2e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins two filesystem path components together using the platform-specific directory separator. <br /></td></tr>
<tr class="separator:afcbe812b6103a4929e749685134d2e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac95f523e167149526b28a8734718658" id="r_aac95f523e167149526b28a8734718658"><td class="memItemLeft" align="right" valign="top"><a id="aac95f523e167149526b28a8734718658" name="aac95f523e167149526b28a8734718658"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>StringStartsWith</b> (const std::string &amp;string, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:aac95f523e167149526b28a8734718658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>string</em> begins with <em>prefix</em>. Returns false if <em>string</em> does not begin with <em>prefix</em>. Comparison is case sensitive. <br /></td></tr>
<tr class="separator:aac95f523e167149526b28a8734718658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7bad93ee38d8c1cf5499a9b2d150b3" id="r_a0d7bad93ee38d8c1cf5499a9b2d150b3"><td class="memItemLeft" align="right" valign="top"><a id="a0d7bad93ee38d8c1cf5499a9b2d150b3" name="a0d7bad93ee38d8c1cf5499a9b2d150b3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>StringEndsWith</b> (const std::string &amp;string, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a0d7bad93ee38d8c1cf5499a9b2d150b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>string</em> ends with <em>suffix</em>. Returns false if <em>string</em> does not end with <em>suffix</em>. Comparison is case sensitive. <br /></td></tr>
<tr class="separator:a0d7bad93ee38d8c1cf5499a9b2d150b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599367daf5dec29272046a0a4ae707a1" id="r_a599367daf5dec29272046a0a4ae707a1"><td class="memItemLeft" align="right" valign="top"><a id="a599367daf5dec29272046a0a4ae707a1" name="a599367daf5dec29272046a0a4ae707a1"></a>
static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SplitString</b> (const std::string &amp;string, char delimiter)</td></tr>
<tr class="memdesc:a599367daf5dec29272046a0a4ae707a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <em>string</em> into substrings using the single character <em>delimiter</em> as the delimiter. <br /></td></tr>
<tr class="separator:a599367daf5dec29272046a0a4ae707a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b607207308a8faea682aeb3e83f3ed" id="r_ac7b607207308a8faea682aeb3e83f3ed"><td class="memItemLeft" align="right" valign="top"><a id="ac7b607207308a8faea682aeb3e83f3ed" name="ac7b607207308a8faea682aeb3e83f3ed"></a>
static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SplitString</b> (const std::string &amp;string, const std::string &amp;delimiter)</td></tr>
<tr class="memdesc:ac7b607207308a8faea682aeb3e83f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <em>string</em> into substrings using the string <em>delimiter</em> as the delimiter. <br /></td></tr>
<tr class="separator:ac7b607207308a8faea682aeb3e83f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1079a6dad9d809d1280cc9131d487ad" id="r_ab1079a6dad9d809d1280cc9131d487ad"><td class="memItemLeft" align="right" valign="top"><a id="ab1079a6dad9d809d1280cc9131d487ad" name="ab1079a6dad9d809d1280cc9131d487ad"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>CreateUuid</b> ()</td></tr>
<tr class="memdesc:ab1079a6dad9d809d1280cc9131d487ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly generated random UUID. <br /></td></tr>
<tr class="separator:ab1079a6dad9d809d1280cc9131d487ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca64444eba2c404a5dd406cbb45879" id="r_a20ca64444eba2c404a5dd406cbb45879"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ca64444eba2c404a5dd406cbb45879">CreateOrTruncateFile</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a20ca64444eba2c404a5dd406cbb45879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure that the file located at <em>path</em> in the filesystem exists and has zero length. If the file does not exist it is created. If the file already exists it is truncated to zero length.  <br /></td></tr>
<tr class="separator:a20ca64444eba2c404a5dd406cbb45879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a329a546999da1524f2111da9af2a6" id="r_a63a329a546999da1524f2111da9af2a6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a329a546999da1524f2111da9af2a6">DeleteFileIfExists</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a63a329a546999da1524f2111da9af2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the file located at <em>path</em> in the filesystem if it exists. Does nothing if the file does not exist.  <br /></td></tr>
<tr class="separator:a63a329a546999da1524f2111da9af2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d185162a3bafddeaa91634a876c2ec" id="r_a09d185162a3bafddeaa91634a876c2ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d185162a3bafddeaa91634a876c2ec">AppendTextToFile</a> (const std::string &amp;path, const std::string &amp;string)</td></tr>
<tr class="memdesc:a09d185162a3bafddeaa91634a876c2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends <em>string</em> to the file located at <em>path</em> in the filesystem. If the file does not exist it is created.  <br /></td></tr>
<tr class="separator:a09d185162a3bafddeaa91634a876c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2060bb1113ea22521553be1d48382e2" id="r_ab2060bb1113ea22521553be1d48382e2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2060bb1113ea22521553be1d48382e2">ReadFileContent</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab2060bb1113ea22521553be1d48382e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the entire content of the file located at <em>path</em> in the filesystem into memory and returns the content as a string.  <br /></td></tr>
<tr class="separator:ab2060bb1113ea22521553be1d48382e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_utility.html" title="The SgfcUtility class is a container for static helper functions.">SgfcUtility</a> class is a container for static helper functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a09d185162a3bafddeaa91634a876c2ec" name="a09d185162a3bafddeaa91634a876c2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d185162a3bafddeaa91634a876c2ec">&#9670;&#160;</a></span>AppendTextToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcUtility::AppendTextToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>string</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends <em>string</em> to the file located at <em>path</em> in the filesystem. If the file does not exist it is created. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Is thrown if the file cannot be opened for writing for any reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20ca64444eba2c404a5dd406cbb45879" name="a20ca64444eba2c404a5dd406cbb45879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ca64444eba2c404a5dd406cbb45879">&#9670;&#160;</a></span>CreateOrTruncateFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcUtility::CreateOrTruncateFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes sure that the file located at <em>path</em> in the filesystem exists and has zero length. If the file does not exist it is created. If the file already exists it is truncated to zero length. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Is thrown if the file cannot be opened for writing for any reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63a329a546999da1524f2111da9af2a6" name="a63a329a546999da1524f2111da9af2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a329a546999da1524f2111da9af2a6">&#9670;&#160;</a></span>DeleteFileIfExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LibSgfcPlusPlus::SgfcUtility::DeleteFileIfExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the file located at <em>path</em> in the filesystem if it exists. Does nothing if the file does not exist. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the file exists and was deleted. </td></tr>
    <tr><td class="paramname">false</td><td>if the file does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Is thrown if the file exists but cannot be deleted for any reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd4cf366fcc948974d7a5df70012284" name="a6dd4cf366fcc948974d7a5df70012284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd4cf366fcc948974d7a5df70012284">&#9670;&#160;</a></span>GetIsSgfDataValidFromMessageCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LibSgfcPlusPlus::SgfcUtility::GetIsSgfDataValidFromMessageCollection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_message.html">ISgfcMessage</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>messageCollection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <em>messageCollection</em>, which is the result of an SGFC read or write operation, indicate that the piece of SGF data that was read or written is valid. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the data that was read or written is valid. </td></tr>
    <tr><td class="paramname">false</td><td>if the data that was read or written is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38484a1ab36f428d57f569cfd2ea84c1" name="a38484a1ab36f428d57f569cfd2ea84c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38484a1ab36f428d57f569cfd2ea84c1">&#9670;&#160;</a></span>GetTempFolderPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::GetTempFolderPath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full path of a folder that is suitable for temporary files. The path is guaranteed to exist and to be a directory. The returned path string is UTF-8 encoded. </p>
<p>The implementation makes use of std::filesystem::temp_directory_path(), which is defined in C++17 but may not be available on older platform versions (notably on macOS it is available only from macOS 10.15). For more details about how the path is determined, see <a href="https://en.cppreference.com/w/cpp/filesystem/temp_directory_path">https://en.cppreference.com/w/cpp/filesystem/temp_directory_path</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::filesystem::filesystem_error</td><td>Is thrown if invoking the underlying operating system API results in an error. The exception object is constructed with the temporary folder path as the first path argument and the operating system error code as the error code argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad15b99a0451db7d677ec999d8ccaf0d6" name="ad15b99a0451db7d677ec999d8ccaf0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15b99a0451db7d677ec999d8ccaf0d6">&#9670;&#160;</a></span>GetUniqueTempFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::GetUniqueTempFileName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique base name of a file that is extremely unlikely to already exist in the temporary folder returned by GetTempPath(). This method never returns the same value twice. </p>
<p>The file name is composed of the following parts:</p><ul>
<li>A prefix that indicates that the file origin is this library</li>
<li>The ID of the system process that hosts the library</li>
<li>A randomly generated UUID</li>
<li>A file extension suffix that indicates that the file is a temporary file </li>
</ul>

</div>
</div>
<a id="aeacf83cf0a47f01aca53a5716e755ed1" name="aeacf83cf0a47f01aca53a5716e755ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacf83cf0a47f01aca53a5716e755ed1">&#9670;&#160;</a></span>GetUniqueTempFilePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::GetUniqueTempFilePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique absolute path of a file that is extremely unlikely to already exist in the temporary folder returned by GetTempPath(). The returned path string is UTF-8 encoded. This method never returns the same value twice. </p>
<p>This is a convenience function that invokes <a class="el" href="#afcbe812b6103a4929e749685134d2e1e" title="Joins two filesystem path components together using the platform-specific directory separator.">JoinPathComponents()</a> using the return values of <a class="el" href="#a38484a1ab36f428d57f569cfd2ea84c1" title="Returns the full path of a folder that is suitable for temporary files. The path is guaranteed to exi...">GetTempFolderPath()</a> and <a class="el" href="#ad15b99a0451db7d677ec999d8ccaf0d6" title="Returns the unique base name of a file that is extremely unlikely to already exist in the temporary f...">GetUniqueTempFileName()</a>. </p>

</div>
</div>
<a id="a1af82426fb2a58b7832538433c6e47f8" name="a1af82426fb2a58b7832538433c6e47f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af82426fb2a58b7832538433c6e47f8">&#9670;&#160;</a></span>MapArgumentTypeToCmdlineOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::MapArgumentTypeToCmdlineOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gafdc227d85ad60d7780ac2eadbd716800">SgfcArgumentType</a></td>          <td class="paramname"><span class="paramname"><em>argumentType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the command line option, as defined by the SGFC documentation, that corresponds to <em>argumentType</em>. </p>
<p>This is a convenience function that looks up <em>argumentType</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_private_constants.html#a7d735890be539306d07022cfb1433866" title="Maps values from the enumeration SgfcArgumentType to command line options as defined by the SGFC docu...">SgfcPrivateConstants::ArgumentTypeToCmdlineOptionMap</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if there is no mapping, i.e. if <em>argumentType</em> does not appear in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_private_constants.html#a7d735890be539306d07022cfb1433866" title="Maps values from the enumeration SgfcArgumentType to command line options as defined by the SGFC docu...">SgfcPrivateConstants::ArgumentTypeToCmdlineOptionMap</a>. In practice this should never occur. If it occurs it indicates a programming error in the library, i.e. an SgfcArgumentType value was not added to <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_private_constants.html#a7d735890be539306d07022cfb1433866" title="Maps values from the enumeration SgfcArgumentType to command line options as defined by the SGFC docu...">SgfcPrivateConstants::ArgumentTypeToCmdlineOptionMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac885906b3fcc411a3788821380911c86" name="ac885906b3fcc411a3788821380911c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac885906b3fcc411a3788821380911c86">&#9670;&#160;</a></span>MapGameTypeToNumberValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#ga2c188a9d33131c58c39162299c847460">SgfcNumber</a> LibSgfcPlusPlus::SgfcUtility::MapGameTypeToNumberValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#ga628677a0792100aa0f813793d9df7750">SgfcGameType</a></td>          <td class="paramname"><span class="paramname"><em>gameType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SgfcNumber value that corresponds to the SgfcGameType value <em>gameType</em>. <em>gameType</em> must not be SgfcGameType::Unknown. </p>
<p>This is a convenience function that looks up <em>gameType</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a5a8a6231aa54e622f0d27fa5a126ac8b" title="Maps values from the enumeration SgfcGameType to Number values as defined by the SGF standard....">SgfcConstants::GameTypeToGameTypeAsNumberMap</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if there is no mapping, i.e. if <em>gameType</em> does not appear in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a5a8a6231aa54e622f0d27fa5a126ac8b" title="Maps values from the enumeration SgfcGameType to Number values as defined by the SGF standard....">SgfcConstants::GameTypeToGameTypeAsNumberMap</a>. This should only occur if <em>gameType</em> is SgfcGameType::Unknown, because obviously that game type has no corresponding Number value. Otherwise this indicates a programming error in the library, i.e. an SgfcGameType value was not added to <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a5a8a6231aa54e622f0d27fa5a126ac8b" title="Maps values from the enumeration SgfcGameType to Number values as defined by the SGF standard....">SgfcConstants::GameTypeToGameTypeAsNumberMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb430d7674c2899e15f1147bf42e001a" name="aeb430d7674c2899e15f1147bf42e001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb430d7674c2899e15f1147bf42e001a">&#9670;&#160;</a></span>MapNumberValueToGameType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#ga628677a0792100aa0f813793d9df7750">SgfcGameType</a> LibSgfcPlusPlus::SgfcUtility::MapNumberValueToGameType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#ga2c188a9d33131c58c39162299c847460">SgfcNumber</a></td>          <td class="paramname"><span class="paramname"><em>gameTypeAsNumber</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SgfcGameType value that corresponds to the Number value <em>gameTypeAsNumber</em>. Returns SgfcGameType::Unknown if the Number value cannot be mapped, which is the case if the Number value does not correspond to one of the known values defined by the SGF standard. </p>
<p>This is a convenience function that looks up <em>gameTypeAsNumber</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#ace26df50242e72890bfbb0b400a01d00" title="Maps game type Number values as defined by the SGF standard to values from the enumeration SgfcGameTy...">SgfcConstants::GameTypeAsNumberToGameTypeMap</a>. </p>

</div>
</div>
<a id="a66c8b22baa01c347f2c62edebd92339b" name="a66c8b22baa01c347f2c62edebd92339b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8b22baa01c347f2c62edebd92339b">&#9670;&#160;</a></span>MapPropertyCategoryToNodeTraits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#ga3c2910dbdcf98ec5e930fe5b518829d7">SgfcNodeTraits</a> LibSgfcPlusPlus::SgfcUtility::MapPropertyCategoryToNodeTraits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a></td>          <td class="paramname"><span class="paramname"><em>propertyCategory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node trait, as defined by the SGF standard, that corresponds to <em>propertyCategory</em>. Returns <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#afdec80eabad744d960012570dd3d2b91" title="An SgfcNodeTraits value that denotes a node that has no traits.">SgfcConstants::NodeTraitsNone</a> if <em>propertyCategory</em> cannot be mapped. </p>
<p>This is a convenience function that looks up <em>propertyCategory</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_private_constants.html#a98ef8e0d5a307dd35bc0bc50151d64c1" title="Maps values from the enumeration SgfcPropertyCategory to values from the enumeration SgfcNodeTrait.">SgfcPrivateConstants::PropertyCategoryToNodeTraitMap</a>. </p>

</div>
</div>
<a id="ac70c763ef71cd1ceb6f7b2a3a0b89cd7" name="ac70c763ef71cd1ceb6f7b2a3a0b89cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70c763ef71cd1ceb6f7b2a3a0b89cd7">&#9670;&#160;</a></span>MapPropertyNameToPropertyType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> LibSgfcPlusPlus::SgfcUtility::MapPropertyNameToPropertyType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>propertyName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SgfcPropertyType value that corresponds to <em>propertyName</em>. Returns <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> if <em>propertyName</em> cannot be mapped, which is the case if <em>propertyName</em> is not the name of a property as defined by the SGF standard. </p>
<p>This is a convenience function that looks up <em>propertyName</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a18bd31d38e4e87adfba8906f403bb9b1" title="Maps property names as defined by the SGF standard to values from the enumeration SgfcPropertyType.">SgfcConstants::PropertyNameToPropertyTypeMap</a>. </p>

</div>
</div>
<a id="a51722243fc5204219b615bde26ca0a61" name="a51722243fc5204219b615bde26ca0a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51722243fc5204219b615bde26ca0a61">&#9670;&#160;</a></span>MapPropertyTypeToPropertyCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a> LibSgfcPlusPlus::SgfcUtility::MapPropertyTypeToPropertyCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a></td>          <td class="paramname"><span class="paramname"><em>propertyType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property category, as defined by the SGF standard, that corresponds to <em>propertyType</em>. </p>
<p>This is a convenience function that looks up <em>propertyType</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a09feba41493d5af59d9d2d45a550a6c9" title="Maps values from the enumeration SgfcPropertyType to values from the enumeration SgfcPropertyCategory...">SgfcConstants::PropertyTypeToPropertyCategoryMap</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if there is no mapping, i.e. if <em>propertyType</em> does not appear in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a09feba41493d5af59d9d2d45a550a6c9" title="Maps values from the enumeration SgfcPropertyType to values from the enumeration SgfcPropertyCategory...">SgfcConstants::PropertyTypeToPropertyCategoryMap</a>. If this occurs it indicates a programming error in the library, i.e. an SgfcPropertyType value was not added to <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a09feba41493d5af59d9d2d45a550a6c9" title="Maps values from the enumeration SgfcPropertyType to values from the enumeration SgfcPropertyCategory...">SgfcConstants::PropertyTypeToPropertyCategoryMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0021b00bd031fd37f9a44c5f28157cf2" name="a0021b00bd031fd37f9a44c5f28157cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0021b00bd031fd37f9a44c5f28157cf2">&#9670;&#160;</a></span>MapPropertyTypeToPropertyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::MapPropertyTypeToPropertyName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a></td>          <td class="paramname"><span class="paramname"><em>propertyType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property name, as defined by the SGF standard, that corresponds to <em>propertyType</em>. <em>propertyType</em> must not be <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a>. </p>
<p>This is a convenience function that looks up <em>propertyType</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#aa997033c36f6fd61e3aa383ae82fb33c" title="Maps values from the enumeration SgfcPropertyType to property names as defined by the SGF standard....">SgfcConstants::PropertyTypeToPropertyNameMap</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if there is no mapping, i.e. if <em>propertyType</em> does not appear in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#aa997033c36f6fd61e3aa383ae82fb33c" title="Maps values from the enumeration SgfcPropertyType to property names as defined by the SGF standard....">SgfcConstants::PropertyTypeToPropertyNameMap</a>. This should only occur if <em>propertyType</em> is <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a>, because obviously that property type has no corresponding property name. Otherwise this indicates a programming error in the library, i.e. an SgfcPropertyType value was not added to <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#aa997033c36f6fd61e3aa383ae82fb33c" title="Maps values from the enumeration SgfcPropertyType to property names as defined by the SGF standard....">SgfcConstants::PropertyTypeToPropertyNameMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4897286a22c488de7de680406804eb40" name="a4897286a22c488de7de680406804eb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4897286a22c488de7de680406804eb40">&#9670;&#160;</a></span>MapPropertyTypeToPropertyTraits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__public-api.html#ga42be009625cd53c61f0cec57792548f9">SgfcPropertyTraits</a> LibSgfcPlusPlus::SgfcUtility::MapPropertyTypeToPropertyTraits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a></td>          <td class="paramname"><span class="paramname"><em>propertyType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property traits, as defined by the SGF standard, that the property with property type <em>propertyType</em> has. </p>
<p>This is a convenience function that looks up <em>propertyType</em> in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a6ac048432e50b83645d80f8d38c00c57" title="Maps values from the enumeration SgfcPropertyType to SgfcPropertyTraits values.">SgfcConstants::PropertyTypeToPropertyTraitsMap</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if there is no mapping, i.e. if <em>propertyType</em> does not appear in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a6ac048432e50b83645d80f8d38c00c57" title="Maps values from the enumeration SgfcPropertyType to SgfcPropertyTraits values.">SgfcConstants::PropertyTypeToPropertyTraitsMap</a>. If this occurs it indicates a programming error in the library, i.e. an SgfcPropertyType value was not added to <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#a6ac048432e50b83645d80f8d38c00c57" title="Maps values from the enumeration SgfcPropertyType to SgfcPropertyTraits values.">SgfcConstants::PropertyTypeToPropertyTraitsMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2060bb1113ea22521553be1d48382e2" name="ab2060bb1113ea22521553be1d48382e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2060bb1113ea22521553be1d48382e2">&#9670;&#160;</a></span>ReadFileContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LibSgfcPlusPlus::SgfcUtility::ReadFileContent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the entire content of the file located at <em>path</em> in the filesystem into memory and returns the content as a string. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Is thrown if the file cannot be opened for reading for any reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/patrick/dev/libsgfcplusplus/src/<a class="el" href="_sgfc_utility_8h_source.html">SgfcUtility.h</a></li>
<li>/Users/patrick/dev/libsgfcplusplus/src/<b>SgfcUtility.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
