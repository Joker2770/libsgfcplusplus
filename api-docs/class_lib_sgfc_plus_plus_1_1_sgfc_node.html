<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsgfc++: LibSgfcPlusPlus::SgfcNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsgfc++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A C++ library that uses SGFC to read and write SGF (Smart Game Format) files.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>LibSgfcPlusPlus</b></li><li class="navelem"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html">SgfcNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lib_sgfc_plus_plus_1_1_sgfc_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LibSgfcPlusPlus::SgfcNode Class Reference<div class="ingroups"><a class="el" href="group__internals.html">Internals</a> &#124; <a class="el" href="group__game-tree.html">Game Tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi...">SgfcNode</a> class provides an implementation of the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface. See the interface header file for documentation.  
 <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sgfc_node_8h_source.html">SgfcNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LibSgfcPlusPlus::SgfcNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_lib_sgfc_plus_plus_1_1_sgfc_node.png" usemap="#LibSgfcPlusPlus::SgfcNode_map" alt=""/>
  <map id="LibSgfcPlusPlus::SgfcNode_map" name="LibSgfcPlusPlus::SgfcNode_map">
<area href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes...." alt="LibSgfcPlusPlus::ISgfcNode" shape="rect" coords="0,0,168,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ae326a79d377a727edd00decf63916f"><td class="memItemLeft" align="right" valign="top"><a id="a1ae326a79d377a727edd00decf63916f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a1ae326a79d377a727edd00decf63916f">SgfcNode</a> ()</td></tr>
<tr class="memdesc:a1ae326a79d377a727edd00decf63916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi...">SgfcNode</a> object. The node has no parent, children or siblings. <br /></td></tr>
<tr class="separator:a1ae326a79d377a727edd00decf63916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5c33a23e63465a888b68269c0568b0"><td class="memItemLeft" align="right" valign="top"><a id="afd5c33a23e63465a888b68269c0568b0"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#afd5c33a23e63465a888b68269c0568b0">~SgfcNode</a> ()</td></tr>
<tr class="memdesc:afd5c33a23e63465a888b68269c0568b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and cleans up the <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi...">SgfcNode</a> object. <br /></td></tr>
<tr class="separator:afd5c33a23e63465a888b68269c0568b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d9d27d8bade98786627201aa8bfec9"><td class="memItemLeft" align="right" valign="top"><a id="a22d9d27d8bade98786627201aa8bfec9"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a22d9d27d8bade98786627201aa8bfec9">GetFirstChild</a> () const</td></tr>
<tr class="memdesc:a22d9d27d8bade98786627201aa8bfec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's first child node. Returns <em>nullptr</em> if the node has no children. <br /></td></tr>
<tr class="separator:a22d9d27d8bade98786627201aa8bfec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11eefe659bb3c602d362625ddfa91d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa11eefe659bb3c602d362625ddfa91d0">SetFirstChild</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node)</td></tr>
<tr class="memdesc:aa11eefe659bb3c602d362625ddfa91d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node's first child node to <em>node</em>, overwriting the previously set first child node. This method performs no relinking of any kind.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa11eefe659bb3c602d362625ddfa91d0">More...</a><br /></td></tr>
<tr class="separator:aa11eefe659bb3c602d362625ddfa91d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35b617078c88a73638c4e1bc8ba22b9"><td class="memItemLeft" align="right" valign="top"><a id="ae35b617078c88a73638c4e1bc8ba22b9"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ae35b617078c88a73638c4e1bc8ba22b9">GetLastChild</a> () const</td></tr>
<tr class="memdesc:ae35b617078c88a73638c4e1bc8ba22b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's last child node. Returns <em>nullptr</em> if the node has no children. <br /></td></tr>
<tr class="separator:ae35b617078c88a73638c4e1bc8ba22b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ef4247d7384de0449a6ef8ca6d8c1b"><td class="memItemLeft" align="right" valign="top"><a id="aa9ef4247d7384de0449a6ef8ca6d8c1b"></a>
virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa9ef4247d7384de0449a6ef8ca6d8c1b">GetChildren</a> () const</td></tr>
<tr class="memdesc:aa9ef4247d7384de0449a6ef8ca6d8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection of child nodes of the node. The collection is ordered, beginning with the first child node and ending with the last child node. The collection is empty if the node has no children. <br /></td></tr>
<tr class="separator:aa9ef4247d7384de0449a6ef8ca6d8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54e03f3e5a255cfef494e7be5cb42b"><td class="memItemLeft" align="right" valign="top"><a id="a9d54e03f3e5a255cfef494e7be5cb42b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a9d54e03f3e5a255cfef494e7be5cb42b">HasChildren</a> () const</td></tr>
<tr class="memdesc:a9d54e03f3e5a255cfef494e7be5cb42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has one or more children. Returns false if the node has no children. <br /></td></tr>
<tr class="separator:a9d54e03f3e5a255cfef494e7be5cb42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad042226e46c43523b76136a5d575a2"><td class="memItemLeft" align="right" valign="top"><a id="a7ad042226e46c43523b76136a5d575a2"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a7ad042226e46c43523b76136a5d575a2">GetNextSibling</a> () const</td></tr>
<tr class="memdesc:a7ad042226e46c43523b76136a5d575a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's next sibling node. Returns <em>nullptr</em> if the node has no next sibling node, i.e. if the node is the last child of its parent. <br /></td></tr>
<tr class="separator:a7ad042226e46c43523b76136a5d575a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7867b017765e9c511a4e5895e2f98126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a7867b017765e9c511a4e5895e2f98126">SetNextSibling</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node)</td></tr>
<tr class="memdesc:a7867b017765e9c511a4e5895e2f98126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node's next sibling node to <em>node</em>, overwriting the previously set next sibling node. This method performs no relinking of any kind.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a7867b017765e9c511a4e5895e2f98126">More...</a><br /></td></tr>
<tr class="separator:a7867b017765e9c511a4e5895e2f98126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184aec354beef3fa6f3ed2a45c227e7"><td class="memItemLeft" align="right" valign="top"><a id="ac184aec354beef3fa6f3ed2a45c227e7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ac184aec354beef3fa6f3ed2a45c227e7">HasNextSibling</a> () const</td></tr>
<tr class="memdesc:ac184aec354beef3fa6f3ed2a45c227e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a next sibling node. Returns false if the node has no next sibling node, i.e. if the node is the last child of its parent. <br /></td></tr>
<tr class="separator:ac184aec354beef3fa6f3ed2a45c227e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa4eb4464b1bc5a4b9d530d73c245b2"><td class="memItemLeft" align="right" valign="top"><a id="a9fa4eb4464b1bc5a4b9d530d73c245b2"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a9fa4eb4464b1bc5a4b9d530d73c245b2">GetPreviousSibling</a> () const</td></tr>
<tr class="memdesc:a9fa4eb4464b1bc5a4b9d530d73c245b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's previous sibling node. Returns <em>nullptr</em> if the node has no previous sibling node, i.e. if the node is the first child of its parent. <br /></td></tr>
<tr class="separator:a9fa4eb4464b1bc5a4b9d530d73c245b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad260f0578f8e4054aaa0bcccdb263f08"><td class="memItemLeft" align="right" valign="top"><a id="ad260f0578f8e4054aaa0bcccdb263f08"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ad260f0578f8e4054aaa0bcccdb263f08">HasPreviousSibling</a> () const</td></tr>
<tr class="memdesc:ad260f0578f8e4054aaa0bcccdb263f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a previous sibling node. Returns false if the node has no previous sibling node, i.e. if the node is the first child of its parent. <br /></td></tr>
<tr class="separator:ad260f0578f8e4054aaa0bcccdb263f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e03ad53fcde4416f67a1f2ad33687e"><td class="memItemLeft" align="right" valign="top"><a id="a82e03ad53fcde4416f67a1f2ad33687e"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a82e03ad53fcde4416f67a1f2ad33687e">GetParent</a> () const</td></tr>
<tr class="memdesc:a82e03ad53fcde4416f67a1f2ad33687e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's parent node. Returns <em>nullptr</em> if the node has no parent node, i.e. if the node is the root node of a game tree. <br /></td></tr>
<tr class="separator:a82e03ad53fcde4416f67a1f2ad33687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db1bebdb187a6570792a0ed66015ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a9db1bebdb187a6570792a0ed66015ee2">SetParent</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node)</td></tr>
<tr class="memdesc:a9db1bebdb187a6570792a0ed66015ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node's parent node to <em>node</em>, overwriting the previously set parent node. This method performs no relinking of any kind.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a9db1bebdb187a6570792a0ed66015ee2">More...</a><br /></td></tr>
<tr class="separator:a9db1bebdb187a6570792a0ed66015ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b28eba4c04a0c86fec5339b4c73e28"><td class="memItemLeft" align="right" valign="top"><a id="a92b28eba4c04a0c86fec5339b4c73e28"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a92b28eba4c04a0c86fec5339b4c73e28">HasParent</a> () const</td></tr>
<tr class="memdesc:a92b28eba4c04a0c86fec5339b4c73e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a parent node. Returns false if the node has no parent node, i.e. if the node is the root node of a game tree. <br /></td></tr>
<tr class="separator:a92b28eba4c04a0c86fec5339b4c73e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7f9e461be2bdb549954bf537f8c39b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#abe7f9e461be2bdb549954bf537f8c39b">IsDescendantOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const</td></tr>
<tr class="memdesc:abe7f9e461be2bdb549954bf537f8c39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#abe7f9e461be2bdb549954bf537f8c39b">More...</a><br /></td></tr>
<tr class="separator:abe7f9e461be2bdb549954bf537f8c39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aaf67a369fd19c4eb882b84553d62b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a73aaf67a369fd19c4eb882b84553d62b">IsAncestorOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const</td></tr>
<tr class="memdesc:a73aaf67a369fd19c4eb882b84553d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a73aaf67a369fd19c4eb882b84553d62b">More...</a><br /></td></tr>
<tr class="separator:a73aaf67a369fd19c4eb882b84553d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a1e6c0cc07527861f4963127112299"><td class="memItemLeft" align="right" valign="top"><a id="a38a1e6c0cc07527861f4963127112299"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a38a1e6c0cc07527861f4963127112299">GetRoot</a> () const</td></tr>
<tr class="memdesc:a38a1e6c0cc07527861f4963127112299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of the game tree that contains the node. Returns <em>nullptr</em> if the node is already the root node. <br /></td></tr>
<tr class="separator:a38a1e6c0cc07527861f4963127112299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae525e7a9e77ddf5c8e1341290d01ad41"><td class="memItemLeft" align="right" valign="top"><a id="ae525e7a9e77ddf5c8e1341290d01ad41"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ae525e7a9e77ddf5c8e1341290d01ad41">IsRoot</a> () const</td></tr>
<tr class="memdesc:ae525e7a9e77ddf5c8e1341290d01ad41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is the root node of a game tree. Returns false if the node is not the root node of a game tree. <br /></td></tr>
<tr class="separator:ae525e7a9e77ddf5c8e1341290d01ad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77896a001b9d9381f30dd86bd6e0810c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a77896a001b9d9381f30dd86bd6e0810c">GetProperties</a> () const</td></tr>
<tr class="memdesc:a77896a001b9d9381f30dd86bd6e0810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a77896a001b9d9381f30dd86bd6e0810c">More...</a><br /></td></tr>
<tr class="separator:a77896a001b9d9381f30dd86bd6e0810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701a8bc76aff1b4a1033f7f1b86c52af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a701a8bc76aff1b4a1033f7f1b86c52af">SetProperties</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&gt; &amp;properties)</td></tr>
<tr class="memdesc:a701a8bc76aff1b4a1033f7f1b86c52af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a701a8bc76aff1b4a1033f7f1b86c52af">More...</a><br /></td></tr>
<tr class="separator:a701a8bc76aff1b4a1033f7f1b86c52af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b2e77f46d6fca803a81fe901114ad4"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa1b2e77f46d6fca803a81fe901114ad4">GetProperty</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType) const</td></tr>
<tr class="memdesc:aa1b2e77f46d6fca803a81fe901114ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property.  <a href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa1b2e77f46d6fca803a81fe901114ad4">More...</a><br /></td></tr>
<tr class="separator:aa1b2e77f46d6fca803a81fe901114ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">LibSgfcPlusPlus::ISgfcNode</a></td></tr>
<tr class="memitem:a4bcee4e2c96432dd68549f00a5b5c3e5 inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="memItemLeft" align="right" valign="top"><a id="a4bcee4e2c96432dd68549f00a5b5c3e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a4bcee4e2c96432dd68549f00a5b5c3e5">ISgfcNode</a> ()</td></tr>
<tr class="memdesc:a4bcee4e2c96432dd68549f00a5b5c3e5 inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:a4bcee4e2c96432dd68549f00a5b5c3e5 inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622c391e5f48473aba1d02989c39c5d inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="memItemLeft" align="right" valign="top"><a id="ac622c391e5f48473aba1d02989c39c5d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ac622c391e5f48473aba1d02989c39c5d">~ISgfcNode</a> ()</td></tr>
<tr class="memdesc:ac622c391e5f48473aba1d02989c39c5d inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and cleans up the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:ac622c391e5f48473aba1d02989c39c5d inherit pub_methods_class_lib_sgfc_plus_plus_1_1_i_sgfc_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi...">SgfcNode</a> class provides an implementation of the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface. See the interface header file for documentation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a77896a001b9d9381f30dd86bd6e0810c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77896a001b9d9381f30dd86bd6e0810c">&#9670;&nbsp;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; LibSgfcPlusPlus::SgfcNode::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order. </p>
<p>The SGF standard does not define an order in which properties have to appear within a node. In fact, it explicitly states that different applications may use different ordering, and that the order may change every time that the SGF data is saved.</p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implements <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a000db75725cf7672c5858dbbfa7522a9">LibSgfcPlusPlus::ISgfcNode</a>.</p>

</div>
</div>
<a id="aa1b2e77f46d6fca803a81fe901114ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b2e77f46d6fca803a81fe901114ad4">&#9670;&nbsp;</a></span>GetProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; LibSgfcPlusPlus::SgfcNode::GetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a>&#160;</td>
          <td class="paramname"><em>propertyType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property. </p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implements <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a6f46f1ce0406c24d3ede9165359d82d9">LibSgfcPlusPlus::ISgfcNode</a>.</p>

</div>
</div>
<a id="a73aaf67a369fd19c4eb882b84553d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aaf67a369fd19c4eb882b84553d62b">&#9670;&nbsp;</a></span>IsAncestorOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LibSgfcPlusPlus::SgfcNode::IsAncestorOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a530560f54b8ffbab77697efc7e37c94f">LibSgfcPlusPlus::ISgfcNode</a>.</p>

</div>
</div>
<a id="abe7f9e461be2bdb549954bf537f8c39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7f9e461be2bdb549954bf537f8c39b">&#9670;&nbsp;</a></span>IsDescendantOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LibSgfcPlusPlus::SgfcNode::IsDescendantOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a64ca01ff3fc72c4078d8957e8cdf4b1e">LibSgfcPlusPlus::ISgfcNode</a>.</p>

</div>
</div>
<a id="aa11eefe659bb3c602d362625ddfa91d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11eefe659bb3c602d362625ddfa91d0">&#9670;&nbsp;</a></span>SetFirstChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcNode::SetFirstChild </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the node's first child node to <em>node</em>, overwriting the previously set first child node. This method performs no relinking of any kind. </p>
<p>This is a library-internal setter method. Library clients should never be able to invoke this directly. Instead library clients must use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a>. </p>

</div>
</div>
<a id="a7867b017765e9c511a4e5895e2f98126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7867b017765e9c511a4e5895e2f98126">&#9670;&nbsp;</a></span>SetNextSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcNode::SetNextSibling </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the node's next sibling node to <em>node</em>, overwriting the previously set next sibling node. This method performs no relinking of any kind. </p>
<p>This is a library-internal setter method. Library clients should never be able to invoke this directly. Instead library clients must use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a>. </p>

</div>
</div>
<a id="a9db1bebdb187a6570792a0ed66015ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db1bebdb187a6570792a0ed66015ee2">&#9670;&nbsp;</a></span>SetParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcNode::SetParent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the node's parent node to <em>node</em>, overwriting the previously set parent node. This method performs no relinking of any kind. </p>
<p>This is a library-internal setter method. Library clients should never be able to invoke this directly. Instead library clients must use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a>. </p>

</div>
</div>
<a id="a701a8bc76aff1b4a1033f7f1b86c52af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701a8bc76aff1b4a1033f7f1b86c52af">&#9670;&nbsp;</a></span>SetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LibSgfcPlusPlus::SgfcNode::SetProperties </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection. </p>
<p>The SGF standard defines that only one of each property is allowed per node. This is the reason why this method prevents setting a collection that contains duplicate property types or names. Names are checked to prevent duplicates of custom properties, which have SgfcPropertyType::Unknow.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>properties</em> contains <em>nullptr</em> elements, or if an SgfcPropertyType other than <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> appears more than once, or if a property name appears more than once. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a36338f0ad9b8ca290f278ec6749a48ed">LibSgfcPlusPlus::ISgfcNode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/patrick/dev/libsgfcplusplus/src/document/<a class="el" href="_sgfc_node_8h_source.html">SgfcNode.h</a></li>
<li>/Users/patrick/dev/libsgfcplusplus/src/document/SgfcNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
