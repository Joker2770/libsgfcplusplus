<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsgfc++: LibSgfcPlusPlus::ISgfcNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsgfc++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A C++ library that uses SGFC to read and write SGF (Smart Game Format) files.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>LibSgfcPlusPlus</b></li><li class="navelem"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LibSgfcPlusPlus::ISgfcNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__public-api.html">Public API</a> &#124; <a class="el" href="group__game-tree.html">Game Tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface provides access to the data of a single SGF node in a tree of SGF nodes. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> also provides methods to navigate the game tree. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> provides no methods to manipulate the game tree - use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a> for that purpose.  
 <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_sgfc_node_8h_source.html">ISgfcNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LibSgfcPlusPlus::ISgfcNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.png" usemap="#LibSgfcPlusPlus::ISgfcNode_map" alt=""/>
  <map id="LibSgfcPlusPlus::ISgfcNode_map" name="LibSgfcPlusPlus::ISgfcNode_map">
<area href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi..." alt="LibSgfcPlusPlus::SgfcNode" shape="rect" coords="0,56,168,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="memItemLeft" align="right" valign="top"><a id="a4bcee4e2c96432dd68549f00a5b5c3e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a4bcee4e2c96432dd68549f00a5b5c3e5">ISgfcNode</a> ()</td></tr>
<tr class="memdesc:a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622c391e5f48473aba1d02989c39c5d"><td class="memItemLeft" align="right" valign="top"><a id="ac622c391e5f48473aba1d02989c39c5d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ac622c391e5f48473aba1d02989c39c5d">~ISgfcNode</a> ()</td></tr>
<tr class="memdesc:ac622c391e5f48473aba1d02989c39c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and cleans up the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:ac622c391e5f48473aba1d02989c39c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c15fbc93d815e7a369e714665bccfc"><td class="memItemLeft" align="right" valign="top"><a id="a95c15fbc93d815e7a369e714665bccfc"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a95c15fbc93d815e7a369e714665bccfc">GetFirstChild</a> () const =0</td></tr>
<tr class="memdesc:a95c15fbc93d815e7a369e714665bccfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's first child node. Returns <em>nullptr</em> if the node has no children. <br /></td></tr>
<tr class="separator:a95c15fbc93d815e7a369e714665bccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6459839224f48d325a404bd9aad00a00"><td class="memItemLeft" align="right" valign="top"><a id="a6459839224f48d325a404bd9aad00a00"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a6459839224f48d325a404bd9aad00a00">GetLastChild</a> () const =0</td></tr>
<tr class="memdesc:a6459839224f48d325a404bd9aad00a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's last child node. Returns <em>nullptr</em> if the node has no children. <br /></td></tr>
<tr class="separator:a6459839224f48d325a404bd9aad00a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d114eb79b9d8548149a5de5d66f209d"><td class="memItemLeft" align="right" valign="top"><a id="a8d114eb79b9d8548149a5de5d66f209d"></a>
virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a8d114eb79b9d8548149a5de5d66f209d">GetChildren</a> () const =0</td></tr>
<tr class="memdesc:a8d114eb79b9d8548149a5de5d66f209d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection of child nodes of the node. The collection is ordered, beginning with the first child node and ending with the last child node. The collection is empty if the node has no children. <br /></td></tr>
<tr class="separator:a8d114eb79b9d8548149a5de5d66f209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ad3208ff78b4bb7686a71bf0ded00c"><td class="memItemLeft" align="right" valign="top"><a id="a86ad3208ff78b4bb7686a71bf0ded00c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a86ad3208ff78b4bb7686a71bf0ded00c">HasChildren</a> () const =0</td></tr>
<tr class="memdesc:a86ad3208ff78b4bb7686a71bf0ded00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has one or more children. Returns false if the node has no children. <br /></td></tr>
<tr class="separator:a86ad3208ff78b4bb7686a71bf0ded00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a3276e6143e7d0b0ef79872686b55"><td class="memItemLeft" align="right" valign="top"><a id="aaf2a3276e6143e7d0b0ef79872686b55"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#aaf2a3276e6143e7d0b0ef79872686b55">GetNextSibling</a> () const =0</td></tr>
<tr class="memdesc:aaf2a3276e6143e7d0b0ef79872686b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's next sibling node. Returns <em>nullptr</em> if the node has no next sibling node, i.e. if the node is the last child of its parent. <br /></td></tr>
<tr class="separator:aaf2a3276e6143e7d0b0ef79872686b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e02d0d3c704a79ac846e378fac2c45"><td class="memItemLeft" align="right" valign="top"><a id="a99e02d0d3c704a79ac846e378fac2c45"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a99e02d0d3c704a79ac846e378fac2c45">HasNextSibling</a> () const =0</td></tr>
<tr class="memdesc:a99e02d0d3c704a79ac846e378fac2c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a next sibling node. Returns false if the node has no next sibling node, i.e. if the node is the last child of its parent. <br /></td></tr>
<tr class="separator:a99e02d0d3c704a79ac846e378fac2c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36219f6f0f19bc9e722543622ced349f"><td class="memItemLeft" align="right" valign="top"><a id="a36219f6f0f19bc9e722543622ced349f"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a36219f6f0f19bc9e722543622ced349f">GetPreviousSibling</a> () const =0</td></tr>
<tr class="memdesc:a36219f6f0f19bc9e722543622ced349f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's previous sibling node. Returns <em>nullptr</em> if the node has no previous sibling node, i.e. if the node is the first child of its parent. <br /></td></tr>
<tr class="separator:a36219f6f0f19bc9e722543622ced349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c572dfac32799e6dd51d213acc3b12c"><td class="memItemLeft" align="right" valign="top"><a id="a7c572dfac32799e6dd51d213acc3b12c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a7c572dfac32799e6dd51d213acc3b12c">HasPreviousSibling</a> () const =0</td></tr>
<tr class="memdesc:a7c572dfac32799e6dd51d213acc3b12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a previous sibling node. Returns false if the node has no previous sibling node, i.e. if the node is the first child of its parent. <br /></td></tr>
<tr class="separator:a7c572dfac32799e6dd51d213acc3b12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42690b50660f2ea35b50d756182811d8"><td class="memItemLeft" align="right" valign="top"><a id="a42690b50660f2ea35b50d756182811d8"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a42690b50660f2ea35b50d756182811d8">GetParent</a> () const =0</td></tr>
<tr class="memdesc:a42690b50660f2ea35b50d756182811d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's parent node. Returns <em>nullptr</em> if the node has no parent node, i.e. if the node is the root node of a game tree. <br /></td></tr>
<tr class="separator:a42690b50660f2ea35b50d756182811d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e275a1df5b0f0f4a47ed868887d3369"><td class="memItemLeft" align="right" valign="top"><a id="a0e275a1df5b0f0f4a47ed868887d3369"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e275a1df5b0f0f4a47ed868887d3369">HasParent</a> () const =0</td></tr>
<tr class="memdesc:a0e275a1df5b0f0f4a47ed868887d3369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a parent node. Returns false if the node has no parent node, i.e. if the node is the root node of a game tree. <br /></td></tr>
<tr class="separator:a0e275a1df5b0f0f4a47ed868887d3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a64ca01ff3fc72c4078d8957e8cdf4b1e">IsDescendantOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const =0</td></tr>
<tr class="memdesc:a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>.  <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a64ca01ff3fc72c4078d8957e8cdf4b1e">More...</a><br /></td></tr>
<tr class="separator:a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530560f54b8ffbab77697efc7e37c94f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a530560f54b8ffbab77697efc7e37c94f">IsAncestorOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const =0</td></tr>
<tr class="memdesc:a530560f54b8ffbab77697efc7e37c94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>.  <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a530560f54b8ffbab77697efc7e37c94f">More...</a><br /></td></tr>
<tr class="separator:a530560f54b8ffbab77697efc7e37c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de673baa575942c87d27f3e9807f9f0"><td class="memItemLeft" align="right" valign="top"><a id="a4de673baa575942c87d27f3e9807f9f0"></a>
virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a4de673baa575942c87d27f3e9807f9f0">GetRoot</a> () const =0</td></tr>
<tr class="memdesc:a4de673baa575942c87d27f3e9807f9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of the game tree that contains the node. Returns <em>nullptr</em> if the node is already the root node. <br /></td></tr>
<tr class="separator:a4de673baa575942c87d27f3e9807f9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e872251106455871a73fbbf5289318"><td class="memItemLeft" align="right" valign="top"><a id="a27e872251106455871a73fbbf5289318"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a27e872251106455871a73fbbf5289318">IsRoot</a> () const =0</td></tr>
<tr class="memdesc:a27e872251106455871a73fbbf5289318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is the root node of a game tree. Returns false if the node is not the root node of a game tree. <br /></td></tr>
<tr class="separator:a27e872251106455871a73fbbf5289318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000db75725cf7672c5858dbbfa7522a9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a000db75725cf7672c5858dbbfa7522a9">GetProperties</a> () const =0</td></tr>
<tr class="memdesc:a000db75725cf7672c5858dbbfa7522a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order.  <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a000db75725cf7672c5858dbbfa7522a9">More...</a><br /></td></tr>
<tr class="separator:a000db75725cf7672c5858dbbfa7522a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36338f0ad9b8ca290f278ec6749a48ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a36338f0ad9b8ca290f278ec6749a48ed">SetProperties</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&gt; &amp;properties)=0</td></tr>
<tr class="memdesc:a36338f0ad9b8ca290f278ec6749a48ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection.  <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a36338f0ad9b8ca290f278ec6749a48ed">More...</a><br /></td></tr>
<tr class="separator:a36338f0ad9b8ca290f278ec6749a48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f46f1ce0406c24d3ede9165359d82d9"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a6f46f1ce0406c24d3ede9165359d82d9">GetProperty</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType) const =0</td></tr>
<tr class="memdesc:a6f46f1ce0406c24d3ede9165359d82d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property.  <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a6f46f1ce0406c24d3ede9165359d82d9">More...</a><br /></td></tr>
<tr class="separator:a6f46f1ce0406c24d3ede9165359d82d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface provides access to the data of a single SGF node in a tree of SGF nodes. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> also provides methods to navigate the game tree. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> provides no methods to manipulate the game tree - use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a> for that purpose. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a000db75725cf7672c5858dbbfa7522a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000db75725cf7672c5858dbbfa7522a9">&#9670;&nbsp;</a></span>GetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::shared_ptr&lt;<a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a>&gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order. </p>
<p>The SGF standard does not define an order in which properties have to appear within a node. In fact, it explicitly states that different applications may use different ordering, and that the order may change every time that the SGF data is saved.</p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a77896a001b9d9381f30dd86bd6e0810c">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a6f46f1ce0406c24d3ede9165359d82d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f46f1ce0406c24d3ede9165359d82d9">&#9670;&nbsp;</a></span>GetProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a>&gt; LibSgfcPlusPlus::ISgfcNode::GetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a>&#160;</td>
          <td class="paramname"><em>propertyType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property. </p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa1b2e77f46d6fca803a81fe901114ad4">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a530560f54b8ffbab77697efc7e37c94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530560f54b8ffbab77697efc7e37c94f">&#9670;&nbsp;</a></span>IsAncestorOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::IsAncestorOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a73aaf67a369fd19c4eb882b84553d62b">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a64ca01ff3fc72c4078d8957e8cdf4b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ca01ff3fc72c4078d8957e8cdf4b1e">&#9670;&nbsp;</a></span>IsDescendantOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::IsDescendantOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#abe7f9e461be2bdb549954bf537f8c39b">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a36338f0ad9b8ca290f278ec6749a48ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36338f0ad9b8ca290f278ec6749a48ed">&#9670;&nbsp;</a></span>SetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::SetProperties </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection. </p>
<p>The SGF standard defines that only one of each property is allowed per node. This is the reason why this method prevents setting a collection that contains duplicate property types or names. Names are checked to prevent duplicates of custom properties, which have SgfcPropertyType::Unknow.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>properties</em> contains <em>nullptr</em> elements, or if an SgfcPropertyType other than <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> appears more than once, or if a property name appears more than once. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a701a8bc76aff1b4a1033f7f1b86c52af">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/patrick/dev/libsgfcplusplus/include/<a class="el" href="_i_sgfc_node_8h_source.html">ISgfcNode.h</a></li>
<li>/Users/patrick/dev/libsgfcplusplus/src/interface/public/ISgfcNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
