<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsgfc++: LibSgfcPlusPlus::ISgfcNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libsgfc++<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">A C++ library that uses SGFC to read and write SGF (Smart Game Format) data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_lib_sgfc_plus_plus.html">LibSgfcPlusPlus</a></li><li class="navelem"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LibSgfcPlusPlus::ISgfcNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__public-api.html">Public API</a> &#124; <a class="el" href="group__game-tree.html">Game Tree</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface provides access to the data of a single SGF node in a tree of SGF nodes. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> also provides methods to navigate the game tree. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> provides no methods to manipulate the game tree - use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a> for that purpose.  
 <a href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_sgfc_node_8h_source.html">ISgfcNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LibSgfcPlusPlus::ISgfcNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.png" usemap="#LibSgfcPlusPlus::ISgfcNode_map" alt=""/>
  <map id="LibSgfcPlusPlus::ISgfcNode_map" name="LibSgfcPlusPlus::ISgfcNode_map">
<area href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html" title="The SgfcNode class provides an implementation of the ISgfcNode interface. See the interface header fi..." alt="LibSgfcPlusPlus::SgfcNode" shape="rect" coords="0,56,168,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bcee4e2c96432dd68549f00a5b5c3e5" id="r_a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="memItemLeft" align="right" valign="top"><a id="a4bcee4e2c96432dd68549f00a5b5c3e5" name="a4bcee4e2c96432dd68549f00a5b5c3e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ISgfcNode</b> ()</td></tr>
<tr class="memdesc:a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:a4bcee4e2c96432dd68549f00a5b5c3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622c391e5f48473aba1d02989c39c5d" id="r_ac622c391e5f48473aba1d02989c39c5d"><td class="memItemLeft" align="right" valign="top"><a id="ac622c391e5f48473aba1d02989c39c5d" name="ac622c391e5f48473aba1d02989c39c5d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ISgfcNode</b> ()</td></tr>
<tr class="memdesc:ac622c391e5f48473aba1d02989c39c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and cleans up the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object. <br /></td></tr>
<tr class="separator:ac622c391e5f48473aba1d02989c39c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Game tree navigation</div></td></tr>
<tr class="memitem:ac7485d1f4ecef9738a723caee4976589" id="r_ac7485d1f4ecef9738a723caee4976589"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ac7485d1f4ecef9738a723caee4976589">GetFirstChild</a> () const =0</td></tr>
<tr class="memdesc:ac7485d1f4ecef9738a723caee4976589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's first child node. Returns <em>nullptr</em> if the node has no children.  <br /></td></tr>
<tr class="separator:ac7485d1f4ecef9738a723caee4976589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d9e430b1db72ba30d562df3fbdd037" id="r_a71d9e430b1db72ba30d562df3fbdd037"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a71d9e430b1db72ba30d562df3fbdd037">GetLastChild</a> () const =0</td></tr>
<tr class="memdesc:a71d9e430b1db72ba30d562df3fbdd037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's last child node. Returns <em>nullptr</em> if the node has no children.  <br /></td></tr>
<tr class="separator:a71d9e430b1db72ba30d562df3fbdd037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0695a5ef1f0fca251daa6a29a8a2516b" id="r_a0695a5ef1f0fca251daa6a29a8a2516b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0695a5ef1f0fca251daa6a29a8a2516b">GetChildren</a> () const =0</td></tr>
<tr class="memdesc:a0695a5ef1f0fca251daa6a29a8a2516b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection of child nodes of the node. The collection is ordered, beginning with the first child node and ending with the last child node. The collection is empty if the node has no children.  <br /></td></tr>
<tr class="separator:a0695a5ef1f0fca251daa6a29a8a2516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ad3208ff78b4bb7686a71bf0ded00c" id="r_a86ad3208ff78b4bb7686a71bf0ded00c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a86ad3208ff78b4bb7686a71bf0ded00c">HasChildren</a> () const =0</td></tr>
<tr class="memdesc:a86ad3208ff78b4bb7686a71bf0ded00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has one or more children. Returns false if the node has no children.  <br /></td></tr>
<tr class="separator:a86ad3208ff78b4bb7686a71bf0ded00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c9c52a1e1b3dfb602d6d9ecb0f96e" id="r_ad17c9c52a1e1b3dfb602d6d9ecb0f96e"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ad17c9c52a1e1b3dfb602d6d9ecb0f96e">GetNextSibling</a> () const =0</td></tr>
<tr class="memdesc:ad17c9c52a1e1b3dfb602d6d9ecb0f96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's next sibling node. Returns <em>nullptr</em> if the node has no next sibling node, i.e. if the node is the last child of its parent.  <br /></td></tr>
<tr class="separator:ad17c9c52a1e1b3dfb602d6d9ecb0f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e02d0d3c704a79ac846e378fac2c45" id="r_a99e02d0d3c704a79ac846e378fac2c45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a99e02d0d3c704a79ac846e378fac2c45">HasNextSibling</a> () const =0</td></tr>
<tr class="memdesc:a99e02d0d3c704a79ac846e378fac2c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a next sibling node. Returns false if the node has no next sibling node, i.e. if the node is the last child of its parent.  <br /></td></tr>
<tr class="separator:a99e02d0d3c704a79ac846e378fac2c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2503e249ef026cf296f5fded3203b682" id="r_a2503e249ef026cf296f5fded3203b682"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2503e249ef026cf296f5fded3203b682">GetPreviousSibling</a> () const =0</td></tr>
<tr class="memdesc:a2503e249ef026cf296f5fded3203b682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's previous sibling node. Returns <em>nullptr</em> if the node has no previous sibling node, i.e. if the node is the first child of its parent.  <br /></td></tr>
<tr class="separator:a2503e249ef026cf296f5fded3203b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c572dfac32799e6dd51d213acc3b12c" id="r_a7c572dfac32799e6dd51d213acc3b12c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a7c572dfac32799e6dd51d213acc3b12c">HasPreviousSibling</a> () const =0</td></tr>
<tr class="memdesc:a7c572dfac32799e6dd51d213acc3b12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a previous sibling node. Returns false if the node has no previous sibling node, i.e. if the node is the first child of its parent.  <br /></td></tr>
<tr class="separator:a7c572dfac32799e6dd51d213acc3b12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0c40274582e8480bc5e68290c63fed" id="r_acf0c40274582e8480bc5e68290c63fed"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#acf0c40274582e8480bc5e68290c63fed">GetParent</a> () const =0</td></tr>
<tr class="memdesc:acf0c40274582e8480bc5e68290c63fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's parent node. Returns <em>nullptr</em> if the node has no parent node, i.e. if the node is the root node of a game tree.  <br /></td></tr>
<tr class="separator:acf0c40274582e8480bc5e68290c63fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e275a1df5b0f0f4a47ed868887d3369" id="r_a0e275a1df5b0f0f4a47ed868887d3369"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e275a1df5b0f0f4a47ed868887d3369">HasParent</a> () const =0</td></tr>
<tr class="memdesc:a0e275a1df5b0f0f4a47ed868887d3369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has a parent node. Returns false if the node has no parent node, i.e. if the node is the root node of a game tree.  <br /></td></tr>
<tr class="separator:a0e275a1df5b0f0f4a47ed868887d3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ca01ff3fc72c4078d8957e8cdf4b1e" id="r_a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a64ca01ff3fc72c4078d8957e8cdf4b1e">IsDescendantOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const =0</td></tr>
<tr class="memdesc:a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>.  <br /></td></tr>
<tr class="separator:a64ca01ff3fc72c4078d8957e8cdf4b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530560f54b8ffbab77697efc7e37c94f" id="r_a530560f54b8ffbab77697efc7e37c94f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a530560f54b8ffbab77697efc7e37c94f">IsAncestorOf</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; node) const =0</td></tr>
<tr class="memdesc:a530560f54b8ffbab77697efc7e37c94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>.  <br /></td></tr>
<tr class="separator:a530560f54b8ffbab77697efc7e37c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e872251106455871a73fbbf5289318" id="r_a27e872251106455871a73fbbf5289318"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a27e872251106455871a73fbbf5289318">IsRoot</a> () const =0</td></tr>
<tr class="memdesc:a27e872251106455871a73fbbf5289318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is the root node of a game tree. Returns false if the node is not the root node of a game tree.  <br /></td></tr>
<tr class="separator:a27e872251106455871a73fbbf5289318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node traits</div></td></tr>
<tr class="memitem:a817972216e860adbe357ce2fec23dcee" id="r_a817972216e860adbe357ce2fec23dcee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__public-api.html#ga3c2910dbdcf98ec5e930fe5b518829d7">SgfcNodeTraits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a817972216e860adbe357ce2fec23dcee">GetTraits</a> () const =0</td></tr>
<tr class="memdesc:a817972216e860adbe357ce2fec23dcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node's traits.  <br /></td></tr>
<tr class="separator:a817972216e860adbe357ce2fec23dcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1359f95add5cfd69310e3c421b8ab1c8" id="r_a1359f95add5cfd69310e3c421b8ab1c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a1359f95add5cfd69310e3c421b8ab1c8">HasTrait</a> (<a class="el" href="group__public-api.html#ga04c91f52eda3884de1580dd93cc73cf7">SgfcNodeTrait</a> trait) const =0</td></tr>
<tr class="memdesc:a1359f95add5cfd69310e3c421b8ab1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has the trait <em>trait</em>. Returns false if the node does not have the trait <em>trait</em>.  <br /></td></tr>
<tr class="separator:a1359f95add5cfd69310e3c421b8ab1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Game tree search</div></td></tr>
<tr class="memitem:a2f3ebf2828c9752698a9464fd819dfc3" id="r_a2f3ebf2828c9752698a9464fd819dfc3"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2f3ebf2828c9752698a9464fd819dfc3">GetRoot</a> () const =0</td></tr>
<tr class="memdesc:a2f3ebf2828c9752698a9464fd819dfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of the game tree that contains the node. Returns the node itself if the node has no parent, i.e. if it is itself the root node.  <br /></td></tr>
<tr class="separator:a2f3ebf2828c9752698a9464fd819dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1f6cf87a9647e3c5f375e04e974ef1" id="r_a0e1f6cf87a9647e3c5f375e04e974ef1"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1">GetGameInfoNode</a> () const =0</td></tr>
<tr class="memdesc:a0e1f6cf87a9647e3c5f375e04e974ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first node among the node itself and its ancestors that has the trait <a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a>. Returns <em>nullptr</em> if there is no such node.  <br /></td></tr>
<tr class="separator:a0e1f6cf87a9647e3c5f375e04e974ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a798a06b4c562dd2df4de981048bcb6" id="r_a9a798a06b4c562dd2df4de981048bcb6"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a9a798a06b4c562dd2df4de981048bcb6">GetMainVariationNodes</a> () const =0</td></tr>
<tr class="memdesc:a9a798a06b4c562dd2df4de981048bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ordered collection of nodes that consists of the node's ancestors up to the root node, the node itself, and the main variation of game play found on the node's first child descendants.  <br /></td></tr>
<tr class="separator:a9a798a06b4c562dd2df4de981048bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Game info access</div></td></tr>
<tr class="memitem:ad2e6424b881be25110577d8e49b3a62f" id="r_ad2e6424b881be25110577d8e49b3a62f"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html">ISgfcGameInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ad2e6424b881be25110577d8e49b3a62f">CreateGameInfo</a> () const =0</td></tr>
<tr class="memdesc:ad2e6424b881be25110577d8e49b3a62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html" title="The ISgfcGameInfo interface ia a collection of meta data that describes one SGF game....">ISgfcGameInfo</a> object with values taken from the properties in the root node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2f3ebf2828c9752698a9464fd819dfc3" title="Returns the root node of the game tree that contains the node. Returns the node itself if the node ha...">GetRoot()</a> returns and the game info node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns.  <br /></td></tr>
<tr class="separator:ad2e6424b881be25110577d8e49b3a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5f3db1b6806d1be1353f90c9b9afe3" id="r_a3d5f3db1b6806d1be1353f90c9b9afe3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a3d5f3db1b6806d1be1353f90c9b9afe3">WriteGameInfo</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html">ISgfcGameInfo</a> &gt; gameInfo) const =0</td></tr>
<tr class="memdesc:a3d5f3db1b6806d1be1353f90c9b9afe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes all root property values in <em>gameInfo</em> to the corresponding properties in the root node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2f3ebf2828c9752698a9464fd819dfc3" title="Returns the root node of the game tree that contains the node. Returns the node itself if the node ha...">GetRoot()</a> returns, and all game info property values in <em>gameInfo</em> to the game info node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns.  <br /></td></tr>
<tr class="separator:a3d5f3db1b6806d1be1353f90c9b9afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property access</div></td></tr>
<tr class="memitem:ac42225383c96e0f306f0009c60b5b7fa" id="r_ac42225383c96e0f306f0009c60b5b7fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ac42225383c96e0f306f0009c60b5b7fa">HasProperties</a> () const =0</td></tr>
<tr class="memdesc:ac42225383c96e0f306f0009c60b5b7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has one or more properties. Returns false if the node has no properties.  <br /></td></tr>
<tr class="separator:ac42225383c96e0f306f0009c60b5b7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d204561afe5abf1c261ae82b4bfc8" id="r_a3f2d204561afe5abf1c261ae82b4bfc8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a3f2d204561afe5abf1c261ae82b4bfc8">GetProperties</a> () const =0</td></tr>
<tr class="memdesc:a3f2d204561afe5abf1c261ae82b4bfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order.  <br /></td></tr>
<tr class="separator:a3f2d204561afe5abf1c261ae82b4bfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cde243c7dbfea3ea4ee36ef84cb806" id="r_aa5cde243c7dbfea3ea4ee36ef84cb806"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#aa5cde243c7dbfea3ea4ee36ef84cb806">SetProperties</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; &amp;properties)=0</td></tr>
<tr class="memdesc:aa5cde243c7dbfea3ea4ee36ef84cb806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection.  <br /></td></tr>
<tr class="separator:aa5cde243c7dbfea3ea4ee36ef84cb806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c12248bb544939e0784f8909dd95851" id="r_a7c12248bb544939e0784f8909dd95851"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a7c12248bb544939e0784f8909dd95851">SetProperty</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; property)=0</td></tr>
<tr class="memdesc:a7c12248bb544939e0784f8909dd95851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>property</em> as the last property to the node's collection of properties. If the collection already contains a duplicate property that duplicate is removed first. <em>property</em> may not be <em>nullptr</em>.  <br /></td></tr>
<tr class="separator:a7c12248bb544939e0784f8909dd95851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2434bccad0cb58e3d3f8365bdda0142" id="r_af2434bccad0cb58e3d3f8365bdda0142"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#af2434bccad0cb58e3d3f8365bdda0142">AppendProperty</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; property)=0</td></tr>
<tr class="memdesc:af2434bccad0cb58e3d3f8365bdda0142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>property</em> as the last property to the node's collection of properties. <em>property</em> may not be <em>nullptr</em>.  <br /></td></tr>
<tr class="separator:af2434bccad0cb58e3d3f8365bdda0142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e45fb564070dfbe0bcf2b633dbe7a" id="r_a4a2e45fb564070dfbe0bcf2b633dbe7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a4a2e45fb564070dfbe0bcf2b633dbe7a">RemoveProperty</a> (std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; property)=0</td></tr>
<tr class="memdesc:a4a2e45fb564070dfbe0bcf2b633dbe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>property</em> from the node's collection of properties.  <br /></td></tr>
<tr class="separator:a4a2e45fb564070dfbe0bcf2b633dbe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3afc4d2d40d268d4ad62ac50ef769f" id="r_a7b3afc4d2d40d268d4ad62ac50ef769f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a7b3afc4d2d40d268d4ad62ac50ef769f">RemoveAllProperties</a> ()=0</td></tr>
<tr class="memdesc:a7b3afc4d2d40d268d4ad62ac50ef769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all properties from the node's collection of properties.  <br /></td></tr>
<tr class="separator:a7b3afc4d2d40d268d4ad62ac50ef769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53bab3ecf2f54908c55a8a6aa57c58c" id="r_ae53bab3ecf2f54908c55a8a6aa57c58c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ae53bab3ecf2f54908c55a8a6aa57c58c">GetProperty</a> (<a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a> propertyType) const =0</td></tr>
<tr class="memdesc:ae53bab3ecf2f54908c55a8a6aa57c58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property.  <br /></td></tr>
<tr class="separator:ae53bab3ecf2f54908c55a8a6aa57c58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bf95f4a4332698a42864cf938baf1" id="r_a257bf95f4a4332698a42864cf938baf1"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a257bf95f4a4332698a42864cf938baf1">GetProperty</a> (const std::string &amp;propertyName) const =0</td></tr>
<tr class="memdesc:a257bf95f4a4332698a42864cf938baf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property with the specified name <em>propertyName</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property.  <br /></td></tr>
<tr class="separator:a257bf95f4a4332698a42864cf938baf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e635ee5604cdf2c9c3421f6209e4ac" id="r_af5e635ee5604cdf2c9c3421f6209e4ac"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#af5e635ee5604cdf2c9c3421f6209e4ac">GetProperties</a> (<a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a> propertyCategory) const =0</td></tr>
<tr class="memdesc:af5e635ee5604cdf2c9c3421f6209e4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection with the properties of the node that are classified as <em>propertyCategory</em>. The collection is empty if the node has no properties with the requested category. The collection has no particular order.  <br /></td></tr>
<tr class="separator:af5e635ee5604cdf2c9c3421f6209e4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8cf3ce936cb9656d36aa7fada76116" id="r_ace8cf3ce936cb9656d36aa7fada76116"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#ace8cf3ce936cb9656d36aa7fada76116">GetInheritedProperties</a> () const =0</td></tr>
<tr class="memdesc:ace8cf3ce936cb9656d36aa7fada76116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a collection with the most recent occurrence of each property that has the trait <a class="el" href="group__public-api.html#gga36d36275c69f2d6eed1be956d9e1d39da6711ce41907fd6bb07b48b7d1f6a60c5" title="The property is an inheritable property. Inheritable properties are properties that affect not only t...">SgfcPropertyTrait::Inheritable</a>, when found on the node itself and its ancestors. The collection is empty if no properties were found. The collection has no particular order.  <br /></td></tr>
<tr class="separator:ace8cf3ce936cb9656d36aa7fada76116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> interface provides access to the data of a single SGF node in a tree of SGF nodes. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> also provides methods to navigate the game tree. <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> provides no methods to manipulate the game tree - use <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_tree_builder.html" title="The ISgfcTreeBuilder interface provides methods to manipulate the nodes of a game tree.">ISgfcTreeBuilder</a> for that purpose. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af2434bccad0cb58e3d3f8365bdda0142" name="af2434bccad0cb58e3d3f8365bdda0142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2434bccad0cb58e3d3f8365bdda0142">&#9670;&#160;</a></span>AppendProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::AppendProperty </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <em>property</em> as the last property to the node's collection of properties. <em>property</em> may not be <em>nullptr</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>property</em> is <em>nullptr</em>, if <em>property</em> is already in the node's collection of properties, or the node's collection of properties already contains another property with the same SgfcPropertyType (except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> which may appear more than once) or the same property name. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ac818c38d4024bfd26367c645e4bc4155">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ad2e6424b881be25110577d8e49b3a62f" name="ad2e6424b881be25110577d8e49b3a62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e6424b881be25110577d8e49b3a62f">&#9670;&#160;</a></span>CreateGameInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html">ISgfcGameInfo</a> &gt; LibSgfcPlusPlus::ISgfcNode::CreateGameInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly constructed <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html" title="The ISgfcGameInfo interface ia a collection of meta data that describes one SGF game....">ISgfcGameInfo</a> object with values taken from the properties in the root node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2f3ebf2828c9752698a9464fd819dfc3" title="Returns the root node of the game tree that contains the node. Returns the node itself if the node ha...">GetRoot()</a> returns and the game info node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns. </p>
<p>If <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns <em>nullptr</em> then the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html" title="The ISgfcGameInfo interface ia a collection of meta data that describes one SGF game....">ISgfcGameInfo</a> object contains only values taken from the properties in the root node, but all values that would normally be taken from the properties in the game info node have default values.</p>
<p>If the content in the root node indicates that the game type is SgfcGameType::Go then the returned object is an <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_go_game_info.html" title="The ISgfcGoGameInfo interface is a specialization of ISgfcGameInfo that contains additional game info...">ISgfcGoGameInfo</a> object. The game type is SgfcGameType::Go in the following cases:</p><ul>
<li>If the root node contains a property of type <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a64f3bd1741ab8d6ba545a1ae09bb8728" title="The type of game that is stored in the game tree. Property value type: Number.">SgfcPropertyType::GM</a> that either has no value, or that has a single Number value, and that value is 0.</li>
<li>Or if the root node does not contain a property of type <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a64f3bd1741ab8d6ba545a1ae09bb8728" title="The type of game that is stored in the game tree. Property value type: Number.">SgfcPropertyType::GM</a>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game.html#a658615a7681192cf02ee5bd1930da675" title="Returns a newly constructed ISgfcGameInfo object with values taken from the properties in the root no...">ISgfcGame::CreateGameInfo()</a> </dd></dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a5a2e22e4f20472de0fd15777320e6c4f">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a0695a5ef1f0fca251daa6a29a8a2516b" name="a0695a5ef1f0fca251daa6a29a8a2516b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0695a5ef1f0fca251daa6a29a8a2516b">&#9670;&#160;</a></span>GetChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection of child nodes of the node. The collection is ordered, beginning with the first child node and ending with the last child node. The collection is empty if the node has no children. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#affac1a5cd88d19ee0e0f78c9347983b0">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ac7485d1f4ecef9738a723caee4976589" name="ac7485d1f4ecef9738a723caee4976589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7485d1f4ecef9738a723caee4976589">&#9670;&#160;</a></span>GetFirstChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetFirstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's first child node. Returns <em>nullptr</em> if the node has no children. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aca08361933248a0736a6986b9af418f1">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a0e1f6cf87a9647e3c5f375e04e974ef1" name="a0e1f6cf87a9647e3c5f375e04e974ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1f6cf87a9647e3c5f375e04e974ef1">&#9670;&#160;</a></span>GetGameInfoNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetGameInfoNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first node among the node itself and its ancestors that has the trait <a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a>. Returns <em>nullptr</em> if there is no such node. </p>
<p>The search starts with the node itself, then progresses to the node's parent, the node's parent's parent, etc. up to the root node of the game tree. The search returns the first node whose <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a817972216e860adbe357ce2fec23dcee" title="Returns the node&#39;s traits.">GetTraits()</a> method returns a value that includes <a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a> </dd>
<dd>
<a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a9a798a06b4c562dd2df4de981048bcb6" title="Returns an ordered collection of nodes that consists of the node&#39;s ancestors up to the root node,...">GetMainVariationNodes()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_weak_ptr</td><td>Is thrown if the method would like to return the node itself, but the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object is not wrapped by an std::shared_ptr somewhere external. It is impossible for the library client to encounter this scenario, it can only occur during internal unit testing. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#af288cf8fef84a20b8d4a27e200b3b9e6">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ace8cf3ce936cb9656d36aa7fada76116" name="ace8cf3ce936cb9656d36aa7fada76116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8cf3ce936cb9656d36aa7fada76116">&#9670;&#160;</a></span>GetInheritedProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetInheritedProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection with the most recent occurrence of each property that has the trait <a class="el" href="group__public-api.html#gga36d36275c69f2d6eed1be956d9e1d39da6711ce41907fd6bb07b48b7d1f6a60c5" title="The property is an inheritable property. Inheritable properties are properties that affect not only t...">SgfcPropertyTrait::Inheritable</a>, when found on the node itself and its ancestors. The collection is empty if no properties were found. The collection has no particular order. </p>
<p>The detailed search logic is this:</p><ul>
<li>Determine a list of properties that have the trait <a class="el" href="group__public-api.html#gga36d36275c69f2d6eed1be956d9e1d39da6711ce41907fd6bb07b48b7d1f6a60c5" title="The property is an inheritable property. Inheritable properties are properties that affect not only t...">SgfcPropertyTrait::Inheritable</a>.</li>
<li>Start examining the node itself, then the node's parent, etc. up to the game tree's root node.</li>
<li>When a node contains one of the inheritable properties, include that property in the search result returned by the method, then stop looking for that particular property.</li>
<li>Stop the search when all properties have been found.</li>
</ul>
<p>The SGF standard's description of inheritable properties includes the concept of a "setting getting cleared". The implication is that if a "setting is cleared" then, from the node's perspective, things should look as if the property that defines the setting has never been there in the first place. Ideally then the search result returned by the method should not include a property if that property's most recent occurrence "cleared the setting". The problem is the interpretation of when a setting is "being cleared". The SGF standard says that this <b>typically</b> happens when the property is set with an empty value - but <b>typically</b> is not <b>always</b>. Because the SGF standard is not definitive about the meaning, the method does not make assumptions. It simply returns a property's most recent occurrence and leaves the interpretation of the property value to the library client. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aed192a74975ec305eae2ddf66109fcd9">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a71d9e430b1db72ba30d562df3fbdd037" name="a71d9e430b1db72ba30d562df3fbdd037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d9e430b1db72ba30d562df3fbdd037">&#9670;&#160;</a></span>GetLastChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetLastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's last child node. Returns <em>nullptr</em> if the node has no children. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a27f5b7904dfe67d1031de34eb460690b">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a9a798a06b4c562dd2df4de981048bcb6" name="a9a798a06b4c562dd2df4de981048bcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a798a06b4c562dd2df4de981048bcb6">&#9670;&#160;</a></span>GetMainVariationNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetMainVariationNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an ordered collection of nodes that consists of the node's ancestors up to the root node, the node itself, and the main variation of game play found on the node's first child descendants. </p>
<p>The main variation is defined as the depth-first path that starts with the node itself and continues along the first child descendants down to the last node that has no more children. The collection that is returned therefore contains the following nodes in the listed order:</p>
<ul>
<li>Element 0: The root node</li>
<li>Element 1: The root node's child that leads to the node itself (not necessarily the first child)</li>
<li>Element 2: The root node child's child that leads to the node itself (not necessarily the first child)</li>
<li>[...]</li>
<li>Element n: The node itself</li>
<li>Element n+1: The node's first child</li>
<li>Element n+2: The node's first child's first child</li>
<li>Etc.</li>
</ul>
<p>If the node is the root node the returned collection's first element is the node itself. If the node has no children the returned collection's last element is the node itself. If the node is the root node and it has no children the returned collection contains only the node itself.</p>
<p>This is a convenience method that is most useful when invoked on a game info node, i.e. a node that has the trait <a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a>. The returned collection fully spans the game tree from root node to leaf node along a distinct path that contains the game info node on which the method was invoked. The returned collection effectively represents a full game.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public-api.html#gga04c91f52eda3884de1580dd93cc73cf7a22eeed3b74b8fe69650bbb9e6ec51ed8" title="The node is a game info node. Game info nodes are nodes that contain one or more game info properties...">SgfcNodeTrait::GameInfo</a> </dd>
<dd>
<a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_weak_ptr</td><td>Is thrown if the method would like to return the node itself, but the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object is not wrapped by an std::shared_ptr somewhere external. It is impossible for the library client to encounter this scenario, it can only occur during internal unit testing. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a1e3fef17bd996caef18f6e27af2ff3fc">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ad17c9c52a1e1b3dfb602d6d9ecb0f96e" name="ad17c9c52a1e1b3dfb602d6d9ecb0f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17c9c52a1e1b3dfb602d6d9ecb0f96e">&#9670;&#160;</a></span>GetNextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's next sibling node. Returns <em>nullptr</em> if the node has no next sibling node, i.e. if the node is the last child of its parent. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a724d33ef6319cc6007f1750d98809cc7">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="acf0c40274582e8480bc5e68290c63fed" name="acf0c40274582e8480bc5e68290c63fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0c40274582e8480bc5e68290c63fed">&#9670;&#160;</a></span>GetParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's parent node. Returns <em>nullptr</em> if the node has no parent node, i.e. if the node is the root node of a game tree. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a10339c9e8cbcd302d60de01e1b54e52d">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a2503e249ef026cf296f5fded3203b682" name="a2503e249ef026cf296f5fded3203b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2503e249ef026cf296f5fded3203b682">&#9670;&#160;</a></span>GetPreviousSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetPreviousSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's previous sibling node. Returns <em>nullptr</em> if the node has no previous sibling node, i.e. if the node is the first child of its parent. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a2d6abff2243ec94a19e68eb60ae45f0b">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a3f2d204561afe5abf1c261ae82b4bfc8" name="a3f2d204561afe5abf1c261ae82b4bfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2d204561afe5abf1c261ae82b4bfc8">&#9670;&#160;</a></span>GetProperties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection with the properties of the node. The collection is empty if the node has no properties. The collection has no particular order. </p>
<p>The SGF standard does not define an order in which properties have to appear within a node. In fact, it explicitly states that different applications may use different ordering, and that the order may change every time that the SGF data is saved.</p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ace11dc1d3e1f5bc5085293af720c3dff">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="af5e635ee5604cdf2c9c3421f6209e4ac" name="af5e635ee5604cdf2c9c3421f6209e4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e635ee5604cdf2c9c3421f6209e4ac">&#9670;&#160;</a></span>GetProperties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; LibSgfcPlusPlus::ISgfcNode::GetProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#ga5fa9f7d6335605ed50e8832d86fc573e">SgfcPropertyCategory</a>&#160;</td>
          <td class="paramname"><em>propertyCategory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection with the properties of the node that are classified as <em>propertyCategory</em>. The collection is empty if the node has no properties with the requested category. The collection has no particular order. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a63acb72d754c8a142f92931a34dc442e">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a257bf95f4a4332698a42864cf938baf1" name="a257bf95f4a4332698a42864cf938baf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bf95f4a4332698a42864cf938baf1">&#9670;&#160;</a></span>GetProperty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property with the specified name <em>propertyName</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property. </p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a87ac7ef6a76894d999af8bbacbb96bb3">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ae53bab3ecf2f54908c55a8a6aa57c58c" name="ae53bab3ecf2f54908c55a8a6aa57c58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53bab3ecf2f54908c55a8a6aa57c58c">&#9670;&#160;</a></span>GetProperty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#gad09039455b42d7073dda61cc5da0a737">SgfcPropertyType</a>&#160;</td>
          <td class="paramname"><em>propertyType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property with the specified type <em>propertyType</em> if the node has such a property. Returns <em>nullptr</em> if the node has no such property. </p>
<p>If <em>propertyType</em> is <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> and the node has several such properties, returns the property that appears first in the list that is returned by <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a3f2d204561afe5abf1c261ae82b4bfc8" title="Returns a collection with the properties of the node. The collection is empty if the node has no prop...">GetProperties()</a>.</p>
<p>The SGF standard defines that only one of each property is allowed per node. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ab7fdcfb6906af14e0dd6e3897e5957ae">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a2f3ebf2828c9752698a9464fd819dfc3" name="a2f3ebf2828c9752698a9464fd819dfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3ebf2828c9752698a9464fd819dfc3">&#9670;&#160;</a></span>GetRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt; LibSgfcPlusPlus::ISgfcNode::GetRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root node of the game tree that contains the node. Returns the node itself if the node has no parent, i.e. if it is itself the root node. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_weak_ptr</td><td>Is thrown if the method would like to return the node itself, but the <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html" title="The ISgfcNode interface provides access to the data of a single SGF node in a tree of SGF nodes....">ISgfcNode</a> object is not wrapped by an std::shared_ptr somewhere external. It is impossible for the library client to encounter this scenario, it can only occur during internal unit testing. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a798476b51f248d2837293e5b5bca31f7">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a817972216e860adbe357ce2fec23dcee" name="a817972216e860adbe357ce2fec23dcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817972216e860adbe357ce2fec23dcee">&#9670;&#160;</a></span>GetTraits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__public-api.html#ga3c2910dbdcf98ec5e930fe5b518829d7">SgfcNodeTraits</a> LibSgfcPlusPlus::ISgfcNode::GetTraits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node's traits. </p>
<p>Returns <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_constants.html#afdec80eabad744d960012570dd3d2b91" title="An SgfcNodeTraits value that denotes a node that has no traits.">SgfcConstants::NodeTraitsNone</a> if the node is not the root node of a game tree and if it has either no properties or only properties with <a class="el" href="group__public-api.html#gga5fa9f7d6335605ed50e8832d86fc573ea387baf0199e7c9cc944fae94e96448fa" title="The property is a miscellaneous property, i.e. it cannot be placed in a more specific category.">SgfcPropertyCategory::Miscellaneous</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public-api.html#ga3c2910dbdcf98ec5e930fe5b518829d7" title="An SgfcNodeTraits value describes the traits of an ISgfcNode object. The value is a combination of in...">SgfcNodeTraits</a> </dd></dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a3bd6e9d3b0b435720c667fdcb643a4ba">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a86ad3208ff78b4bb7686a71bf0ded00c" name="a86ad3208ff78b4bb7686a71bf0ded00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ad3208ff78b4bb7686a71bf0ded00c">&#9670;&#160;</a></span>HasChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has one or more children. Returns false if the node has no children. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a8faa1239610ab3f334a67e147e8580d3">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a99e02d0d3c704a79ac846e378fac2c45" name="a99e02d0d3c704a79ac846e378fac2c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e02d0d3c704a79ac846e378fac2c45">&#9670;&#160;</a></span>HasNextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has a next sibling node. Returns false if the node has no next sibling node, i.e. if the node is the last child of its parent. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a32c252c4880912eebe886ec39e2b90e5">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a0e275a1df5b0f0f4a47ed868887d3369" name="a0e275a1df5b0f0f4a47ed868887d3369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e275a1df5b0f0f4a47ed868887d3369">&#9670;&#160;</a></span>HasParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has a parent node. Returns false if the node has no parent node, i.e. if the node is the root node of a game tree. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a1455676d359bb90135911a786c93d5a8">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a7c572dfac32799e6dd51d213acc3b12c" name="a7c572dfac32799e6dd51d213acc3b12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c572dfac32799e6dd51d213acc3b12c">&#9670;&#160;</a></span>HasPreviousSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasPreviousSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has a previous sibling node. Returns false if the node has no previous sibling node, i.e. if the node is the first child of its parent. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ab4a3be18e71d083ef379343d8d333884">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="ac42225383c96e0f306f0009c60b5b7fa" name="ac42225383c96e0f306f0009c60b5b7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42225383c96e0f306f0009c60b5b7fa">&#9670;&#160;</a></span>HasProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has one or more properties. Returns false if the node has no properties. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a84aac6eeda7f1d9087e1b0cbde65134b">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a1359f95add5cfd69310e3c421b8ab1c8" name="a1359f95add5cfd69310e3c421b8ab1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1359f95add5cfd69310e3c421b8ab1c8">&#9670;&#160;</a></span>HasTrait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::HasTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__public-api.html#ga04c91f52eda3884de1580dd93cc73cf7">SgfcNodeTrait</a>&#160;</td>
          <td class="paramname"><em>trait</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node has the trait <em>trait</em>. Returns false if the node does not have the trait <em>trait</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__public-api.html#ga04c91f52eda3884de1580dd93cc73cf7" title="SgfcNodeTrait enumerates the individual traits that an ISgfcNode object can have. An ISgfcNode object...">SgfcNodeTrait</a> </dd></dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ade324ac438c5ba5c78e4c77b35cea02a">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a530560f54b8ffbab77697efc7e37c94f" name="a530560f54b8ffbab77697efc7e37c94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530560f54b8ffbab77697efc7e37c94f">&#9670;&#160;</a></span>IsAncestorOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::IsAncestorOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is an ancestor of <em>node</em>, i.e. if the node is a direct or indirect parent of <em>node</em>. Returns false if the node is not an ancestor of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ab81e4c54bd712aa203982601a509e0e6">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a64ca01ff3fc72c4078d8957e8cdf4b1e" name="a64ca01ff3fc72c4078d8957e8cdf4b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ca01ff3fc72c4078d8957e8cdf4b1e">&#9670;&#160;</a></span>IsDescendantOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::IsDescendantOf </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html">ISgfcNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is a descendant of <em>node</em>, i.e. if the node is anywhere below <em>node</em> in the game tree. Returns false if the node is not a descendant of <em>node</em>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>node</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a0461df08faefa27b513c316d49bebba7">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a27e872251106455871a73fbbf5289318" name="a27e872251106455871a73fbbf5289318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e872251106455871a73fbbf5289318">&#9670;&#160;</a></span>IsRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LibSgfcPlusPlus::ISgfcNode::IsRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is the root node of a game tree. Returns false if the node is not the root node of a game tree. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a30b468ebe63169ba3ab25681ad25eee4">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a7b3afc4d2d40d268d4ad62ac50ef769f" name="a7b3afc4d2d40d268d4ad62ac50ef769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3afc4d2d40d268d4ad62ac50ef769f">&#9670;&#160;</a></span>RemoveAllProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::RemoveAllProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all properties from the node's collection of properties. </p>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#abbdb7b1bfa6c2968787600dcbc907f0a">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a4a2e45fb564070dfbe0bcf2b633dbe7a" name="a4a2e45fb564070dfbe0bcf2b633dbe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2e45fb564070dfbe0bcf2b633dbe7a">&#9670;&#160;</a></span>RemoveProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::RemoveProperty </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes <em>property</em> from the node's collection of properties. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>property</em> is not part of the node's collection of properties. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#ad7a3dd56eacbde7cf13e6e8e0f35a085">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="aa5cde243c7dbfea3ea4ee36ef84cb806" name="aa5cde243c7dbfea3ea4ee36ef84cb806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cde243c7dbfea3ea4ee36ef84cb806">&#9670;&#160;</a></span>SetProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::SetProperties </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the properties of the node to the collection <em>properties</em>. The collection may be empty. The order in which properties appear in the collection is irrelevant. No SgfcPropertyType except <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> may appear more than once in the collection. No property name may appear more than once in the collection. </p>
<p>The SGF standard defines that only one of each property is allowed per node. This is the reason why this method prevents setting a collection that contains duplicate property types or names. Names are checked to prevent duplicates of custom properties, which have SgfcPropertyType::Unknow.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>properties</em> contains <em>nullptr</em> elements, or if an SgfcPropertyType other than <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> appears more than once, or if a property name appears more than once. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#a4b9299b9516459d9151a1ffbe2a4d6c7">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a7c12248bb544939e0784f8909dd95851" name="a7c12248bb544939e0784f8909dd95851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c12248bb544939e0784f8909dd95851">&#9670;&#160;</a></span>SetProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::SetProperty </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_property.html">ISgfcProperty</a> &gt;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <em>property</em> as the last property to the node's collection of properties. If the collection already contains a duplicate property that duplicate is removed first. <em>property</em> may not be <em>nullptr</em>. </p>
<p>Duplicate elimination works like this:</p><ul>
<li>If <em>property</em> has <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> then the collection is searched for a duplicate by property name only.</li>
<li>If <em>property</em> has a property type that is not <a class="el" href="group__public-api.html#ggad09039455b42d7073dda61cc5da0a737a88183b946cc5f0e8c96b2e66e1c74a7e" title="The property type is unknown, i.e. the property is a custom property not defined by the SGF standard.">SgfcPropertyType::Unknown</a> then the collection is searched for a duplicate both by property type and by property name.</li>
</ul>
<p>The method does nothing if the node's collection of properties already contains <em>property</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>property</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#aa9e27cdc111f3466ea45423688b4785f">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<a id="a3d5f3db1b6806d1be1353f90c9b9afe3" name="a3d5f3db1b6806d1be1353f90c9b9afe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5f3db1b6806d1be1353f90c9b9afe3">&#9670;&#160;</a></span>WriteGameInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LibSgfcPlusPlus::ISgfcNode::WriteGameInfo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_game_info.html">ISgfcGameInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>gameInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes all root property values in <em>gameInfo</em> to the corresponding properties in the root node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a2f3ebf2828c9752698a9464fd819dfc3" title="Returns the root node of the game tree that contains the node. Returns the node itself if the node ha...">GetRoot()</a> returns, and all game info property values in <em>gameInfo</em> to the game info node that <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns. </p>
<p>If <a class="el" href="class_lib_sgfc_plus_plus_1_1_i_sgfc_node.html#a0e1f6cf87a9647e3c5f375e04e974ef1" title="Returns the first node among the node itself and its ancestors that has the trait SgfcNodeTrait::Game...">GetGameInfoNode()</a> returns <em>nullptr</em> then the game info property values in <em>gameInfo</em> are written to the root node.</p>
<p>Game info property values are written only if they are not equal to their default values (already existing property values are overwritten). Game info property values that are equal to their default value cause the property to be removed, if it exists, from the game info node.</p>
<p>Root property values are always written, regardless of whether they are equal to their default values.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Is thrown if <em>gameInfo</em> is <em>nullptr</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lib_sgfc_plus_plus_1_1_sgfc_node.html#af7926d732aff1e86c456bbaccfef5aec">LibSgfcPlusPlus::SgfcNode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/patrick/dev/libsgfcplusplus/include/<a class="el" href="_i_sgfc_node_8h_source.html">ISgfcNode.h</a></li>
<li>/Users/patrick/dev/libsgfcplusplus/src/interface/public/<b>ISgfcNode.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
