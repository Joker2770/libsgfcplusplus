# Library design and working principles

## Public API vs. private implementation

The library has been designed with a strict separation of the library's public API from the library's private implementation.

All public types are one of the following:

- An interface, declared as an abstract class because C++ does not have an `interface` keyword.
- A type with no behaviour, such as a simple struct data type, an enumeration or a typedef.
- A `static`-declared factory class `SgfcPlusPlusFactory`.

The library-internal types that provide the implementations for the public interfaces are marked with a declaration that explicitly sets symbol visibility of these types to "hidden". The goal is that the library client never instantiates library objects on its own, but instead uses the top-level factory class `SgfcPlusPlusFactory` to do so.

## Memory management

The library attempts to protect the library client from having to perform any sort of memory management by making use of `std::shared_ptr`. This smart pointer type has been introduced to the C++ standard in C++11, and if you don't know it yet then you should be quick to [learn more about it](https://en.cppreference.com/w/cpp/memory/shared_ptr).

The goal is, essentially, that the library client can pass around references to library objects without having to constantly think about pointer/reference mechanics and who is responsible for destroying those objects. For example, after the library client has read an SGF file and has obtained a reference to the resulting `ISgfcDocument` object, the entire object tree that represents the game trees in the SGF file can be safely passed around using the `ISgfcDocument` reference. Once the library client removes the last reference to the `ISgfcDocument` object, the entire object tree will be safely deallocated.

In a few places where it is necessary to break reference cycles the library uses `std::weak_ptr` instead of `std::shared_ptr`.

A number of interfaces contain convenience methods that help with downcasting the interface type to a more specific sub-type. These methods are named `To...()` and return a raw pointer without an encapsulating `std::shared_ptr`. The caller of any these methods is not the owner of the returned object and must **never** destroy the returned object. Example: `ToNumberValue()` and many other similar methods in `ISgfcSinglePropertyValue`.

## Thread safety

The library is designed to be thread-safe.

Where it concerns the library code itself, thread safety is achieved simply by avoiding global and static-declared variables. The only `static`-declared entities are:

- Constants that are initialized once when the runtime starts (e.g. members of `SgfcConstants`)
- Classes and/or methods that have no state (e.g. `SgfcPlusPlusFactory`)

Where it concerns the SGFC code wrapped by the library, things are not quite that simple. SGFC uses many global and `static`-declared variables which cannot be "patched away" without also fundamentally changing the way how SGFC was coded. Whether or not this is a flaw in SGFC is debatable, after all SGFC was written as a command line utility and therefore the code rightfully can expect to run only once. In any case, the library works around the problem by funnelling all SGFC operations through a single "gate keeper" class (`SgfcBackendController`). To ensure thread safety this gate keeper uses a central `std::mutex` to serialize all SGFC operations. Because of this no two operations can ever run at the same time.

In addition to serializing SGFC operations, the gate keeper also takes action to allow the repeated use of SGFC in the first place. The most important points here are:

- At the start of an operation the gate keeper resets all of SGFC's global state to initial values, just as if the SGFC command line program had started up from scratch. It does this by executing a series of functions added to SGFC by a patch (`005-resetglobalvariables.patch`).
- The gate keeper takes responsibility for deallocating memory allocated by SGFC as a result of parsing SGF data.

## Operation modes

The library has abstracted SGFC's functionality into 3 interfaces which can be seen to represent the library's main operation modes:

1. Command line mode. The interface for this is `ISgfcCommandLine`. In this mode the library mimics SGFC's command line usage. This mode gives the library client no access to the actual SGF data. In this mode the library client can do the following:
  - The library client specifies the path to a single .sgf file, or an in-memory string buffer with SGF data. The file or in-memory string buffer can have any of the formats FF1 - FF4. The library instructs SGFC to load the SGF data from the file or in-memory string buffer. The library retains the unaltered SGFC-internal data structures.
  - The library client accesses the messages generated by SGFC during parsing.
  - The library client optionally specifies the path to a single .sgf file, or it specifies an in-memory string buffer. The library instructs SGFC to write the SGF data in the unaltered SGFC-internal data structures to the specified file or in-memory string buffer. The file or in-memory string buffer has the FF4 format.
2. Read data mode. The interface for this is `ISgfcDocumentReader`. The library uses SGFC for reading SGF data from a source specified by the library client, and makes that data available to the client for further processing. In this mode the library client can do the following:
  - The library client specifies the path to a single .sgf file, or an in-memory string buffer with SGF data. The file or in-memory string buffer can have any of the formats FF1 - FF4. The library instructs SGFC to load the SGF data from the file or in-memory string buffer. The library transforms the SGFC-internal data structures into its own library-specific data structures that conform to FF4. This may include alterations that cannot be reversed, i.e. it may be impossible to transform the library-specific data structures back into SGFC-internal data structures that are exactly the same as the original SGFC-internal data structures.
  - The library client accesses the messages generated by SGFC during parsing.
  - The library client accesses the SGF data in the form of library-specific data structures (`ISgfcDocument`).
3. Save data mode. The interface for this is `ISgfcDocumentWriter`. The library uses SGFC for writing SGF data provided by the library client to a destination also specified by the library client. In this mode the library client can do the following:
  - The client specifies the SGF data in the form of library-specific data structures (`ISgfcDocument`).
  - The client specifies the path to a single .sgf file, or it specifies an in-memory string buffer. The library transforms the library-specific data structures into SGFC-internal data structures. The library instructs SGFC to write the SGF data in the SGFC-internal data structures to the specified file or in-memory string buffer. The file or in-memory string buffer has the FF4 format.

In all of these modes the library client can specify arguments that indicate how SGFC should perform the read and/or write operations. The available arguments are a subset of the SGFC command line arguments. Certain arguments (e.g. `--help`, `-i`) are not available because they do not make sense in a library context, or because the library does not support them.

## File system interaction

In all three operation modes described in the previous section the library client can specify an in-memory string buffer as source or destination for the SGF data. Even though on the surface it seems as if no interaction with the file system occurs in this usage scenario, this is not true.

It should be noted that even in the in-memory string buffer scenario, under the hood either the library or SGFC writes the SGF data to a temporary file, then reads the data again from that file.

The reason is simple: Less modifications to SGFC were required to implement the functionality. If the way how this is currently implemented proves to be a problem, it should be possible to further patch SGFC so that file system interaction is no longer necessry.

## Error handling

### SGFC messages

When SGFC reads or writes SGF data it often generates one or more messages. Every message has an ID, and every message ID is an indicator for what the message is about. The SGFC documentation lists all messages with their IDs and meanings.

The library parses the raw message strings generated by SGFC and makes them available to the library client in the form of a collection of `ISgfcMessage` objects. These objects provide the information in the raw message strings in a structured form so that the library client can programmatically evaluate the message content and possibly handle certain warnings or errors.

### Exceptions

Yes, the library **does** throw exceptions! The API documentation mentions all exceptions that can be thrown. The library client is responsible to handle the documented exceptions, or face the consequences. Any exceptions that are thrown are thrown by value so the library client can catch them by reference (e.g. `catch (std::invalid_argument& e)`).

The library throws certain exceptions when the library client makes mistakes using the library API. Examples:

- The library client creates an `ISgfcCommandLine` object with invalid arguments and calls its `LoadSgfFile` method without checking first whether the arguments were valid.
- The library client specifies `nullptr` to `SgfcPlusPlusFactory::CreateDocument`.

The library may also throw `std::domain_error` when an unexpected SGFC interfacing problem occurs. Although this may not be the fault of the library client, the design goal here is to fail fast and hard to find out about such problems sooner rather than later. If you encounter such a problem don't hesitate to file a bug report!

Full disclosure: The library can throw `std::logic_error` when a library coding error occurs (e.g. an enumeration value was forgotten in a `switch` statement). Obviously this should never happen, unit tests should have caught such problems before they library was released, etc. etc. Again, the design goal is to find these problems and not sweep them under the rug. Apologies in advance if it *does* happen, and please file a bug report.

## Document concept

When the library reads SGF data from a source, it makes that data available as an `ISgfcDocument`. Currently such a document is equivalent to what the SGF standard shows as a "collection of game trees" in its EBNF definition.

In a future version of the library the document concept might be expanded. For instance it might be possible to add meta data to a document.

## Go support

The SGF standard does not specify how to interpret Point, Stone and Move property values. However, the library treats Go as a first class citizen, in a similar way that SGFC does, and provides the following Go-specific types:

- `ISgfcGoPoint` and `ISgfcGoPointPropertyValue`
- `ISgfcGoStone` and `ISgfcGoStonePropertyValue`
- `ISgfcGoMove` and `ISgfcGoMovePropertyValue`

In order for this support to be possible, the library needs to analyze the game type and board size properties (GM and SZ). For this purpose the library makes the following special property types available:

- `ISgfcGameTypeProperty`
- `ISgfcBoardSizeProperty`

## SGF conformity

Some notes regarding SGF conformity:

- The following has been repeatedly stated elsewhere, but to reiterate:
  - SGF data read by the library (SGFC) can be in any of the FF1 - FF4 formats.
  - SGF data written by the library (SGFC) is always in the FF4 format.
  - When `ISgfcDocumentReader` reads SGF data, the object tree under the resulting `ISgfcDocument` is already in FF4 format.
- The EBNF in the SGF standard says that a property must have at least one value. This can be a value that has the value type "None", which the SGF standard defines to be an empty string. The meaning for the file content is clear: Something like `XY[]` is possible. In the library's object model, however, a "None" value is translated to an empty collection of property values. In other words, `ISgfcProperty::GetPropertyValues` returns a collection with zero elements.
- The library makes no attempt to check the validity of property values assigned to a property with `ISgfcProperty::SetPropertyValues`. A last-ditch attempt at validation is made by SGFC later when the SGF data is written to a destination, but this is unlikely to catch all mistakes. It is ultimately the responsibility of the library client to take care that the values are valid. The consequence of faulty values is that the library client might be unable to read in the game tree again after it has been written out.

## Escaping

The SGF standard requires that certain characters need to be escaped to protect them from  interpretation by an SGF parser (e.g. by SGFC). For instance a closing brace character "]" that appears in a SimpleText property value must be escaped.

libsgfc++ performs escaping and unescaping on behalf of the library client, so the library client can work naturally with unescaped values at all times. The library does this for properties of type Text, SimpleText, Point, Stone and Move.

Let's assume a SimpleText property value "foo [bar]". In an .sgf file that value will appear as "foo [bar\]". When the library client reads the .sgf file it will see the already unescaped value "foo [bar]". When the library client wants to write an .sgf file it can use the unescaped value and libsgfc++ will add the escape character on the fly.

**Note:** If the library client performs its own escaping, the resulting SGF content will be "double-escaped".

## Line breaks

TODO

## Virtual inheritance

Because C++ does not have a dedicated interface feature, the library implementation is forced to employ multiple inheritance. The interface class `ISgfcSinglePropertyValue` is inherited multiple times in all typed property value classes (e.g. `SgfcColorPropertyValue`):

- Once via the `SgfcSinglePropertyValue` base class
- Once via the typed interface class (e.g. `ISgfcColorPropertyValue`)

To make this work all sub-classes of `ISgfcSinglePropertyValue` have to use virtual inheritance. This makes sure that objects contain only one shared `ISgfcSinglePropertyValue` instance.

Without virtual inheritance a class such as `SgfcColorPropertyValue` cannot be instantiated because the compiler sees it as abstract, because `SgfcColorPropertyValue` does not implement all pure virtual methods that it inherits via the `ISgfcColorPropertyValue` base class.

Other classes that also have to use virtual inheritance due to the same reasons:

- Subclasses of `ISgfcProperty` (because of typed property classes such as `SgfcGameTypeProperty`)
- Subclasses of `ISgfcMovePropertyValue`(because of `SgfcGoMovePropertyValue`)
- Subclasses of `ISgfcPointPropertyValue`(because of `SgfcGoPointPropertyValue`)
- Subclasses of `ISgfcStonePropertyValue`(because of `SgfcGoStonePropertyValue`)